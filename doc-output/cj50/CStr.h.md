<!-- THIS FILE WAS AUTO-GENERATED by gendoc. DO NOT EDIT! -->

# Types

## CStr {#zero_CStr}

```C
typedef struct CStr {
    char* cstr;
} CStr
```

`CStr` is a mutable owned type that represents a "C string". It
embeds an array of `char`, that represents the text and a '\0'
character after it to signal the end of the text. There is no
length information, the length has to be determined by walking the
array until encountering the '\0' character (`strlen` will do
that). In addition to `cstr` it guarantees that there are no '\0'
characters contained in the text (functions generating `CStr` must
verify for that to be true).

# Type aliases

## cstr {#zero.one_cstr}

```C
typedef const char* cstr
```

`cstr` is a non-mutable borrowed type that represents a "C
string". It is an array of `char`, that represents the text and a
'\0' character after it to signal the end of the text. There is no
length information, the length has to be determined by walking the
array until encountering the '\0' character (`strlen` will do
that).

# Normal functions

## cStr_from_cstr {#one_cStr_from_cstr}

```C
Result(CStr, CStrError) cStr_from_cstr(char *s, size_t siz)
```

Consume `s`, verify that it ends with a '\0' but does not contain
any '\0' elsewhere. `siz` is the length including the '\0'
terminator.

## new_CStr {#one_new_CStr}

```C
CStr new_CStr(size_t len)
```

Allocate space for a C string of capacity `len`. Aborts when there
is not enough memory. All slots are set to '\0' (the string starts
out as the empty string).

NOTE: This means that the contained cstr is *not* a '\0'-less
string as required by `cStr_from_cstr` with regards to `len`. It
is shortened to the first '\0' encountered. Mutating the contained
cstr is *unsafe* (nothing except your being careful is preventing
you from writing behind the end of the contained cstr (buffer
overflow), and nothing is preventing you from filling it with
non-'\0' characters till the end meaning it loses its terminator).

# Macros

## CStr_from_cstr_unsafe {#three_CStr_from_cstr_unsafe}

```C
CStr_from_cstr_unsafe(s) ((CStr)
```

Generate a `CStr` from a `cstr`. `cstr` must end with a '\0' and
not contain any '\0' in other places; this is not checked, hence
unsafe.

<hr>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
