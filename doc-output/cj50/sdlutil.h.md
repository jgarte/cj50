<!-- THIS FILE WAS AUTO-GENERATED by gendoc. DO NOT EDIT! -->


Utilities for working with the SDL2 library.

This directly uses (only) some of the types that the SDL2 library defines;
and it offers functions that follow the style and use the types from the
cj50 library, to make programming graphics nicer. It might not have some
functionality that you want, though, in which case it might be useful to
check the [SDL2 documentation](https://wiki.libsdl.org/SDL2/FrontPage);
functions on `SDL_Renderer` for example can easily be called from a
`renderframe` function (as passed to `graphics_render`). Mostly that
shouldn't be necessary, though; if missing, it should be added to cj50.

But note that SDL2 doesn't offer many shapes, either; if you need
complicated shapes, the way to do that with SDL2 (as with realtime graphics
programming in general) is to compose the drawing from triangles--this
offers complete freedom about the shape and its coloring and is still
efficient. cj50 offers an abstraction, `VertexRenderer` (which is built on
top of SDL2's `SDL_RenderGeometry`), to do this. The way how this works is
to first call `new_VertexRenderer`, then add vertices (points with colors)
to it and then add triangles build from those vertices; then when your shape
is complete, you call `render_VertexRenderer` to send it to the screen. See
[examples/vertexgraphics.c](../examples/vertexgraphics.c) for an example.

(TODO) The functions around Texture aren't worked out well yet.

# Types

## Texture {#zero_Texture}

```C
typedef struct Texture {
    SDL_Texture *ptr;
} Texture
```

Managing an owned SDL_Texture.

## Vertex {#zero_Vertex}

```C
typedef struct Vertex {
    Vec2(float) position;
    SDL_Color color;
    Vec2(float) texture_position;
} Vertex
```

A `Vertex` is a float-based position on the screen, color at that
point, and (optionally, can be set to {0, 0}) offset into a
texture, used for `VertexRenderer` based drawing.

It is memory-layout compatible with `SDL_Vertex`.

## VertexRenderer {#zero_VertexRenderer}

```C
typedef struct VertexRenderer {
    Vec(Vertex) vertices;
    Vec(Vec3(int)) indices;
} VertexRenderer
```

A `VertexRenderer` collects vertices, and triples of indices into
the vertices vector representing triangles. The collected
triangles information can then be shown via the
`render_VertexRenderer` function.

# Normal functions

## sleep_float {#one_sleep_float}

```C
void sleep_float(float duration_seconds)
```

Sleep the given duration in seconds. Note: this will block the
current thread for that duration, and if that thread is updating
the display or reacting to keyboard input, it will not do so for
the given duration.

## rendersleep {#one_rendersleep}

```C
void rendersleep(SDL_Renderer *rdr)
```

Sleep for the number of seconds (as a float) stored in the global
`rendersleep_seconds` variable (0.01 seconds by default), but first flush
the past drawing commands to the display (via `SDL_RenderPresent`). This can
be useful for debugging purposes to track how a program is drawing.

Note: this (obviously?) won't show any `VertexRenderer` that the program
might have created and been filling; the program is responsible to call
`render_VertexRenderer` on those before calling `rendersleep`, if you want
to see their contents.

## graphics_render {#one_graphics_render}

```C
void graphics_render(cstr title,
                     Vec2(int) window_dimensions,
                     bool (*renderframe)(SDL_Renderer*, void*, Vec2(int)),
                     void* context)
```

Open a window with the given window size, and call `renderframe`
about 60 times per second to draw a new image each
time.

`renderframe` is called with a `SDL_Renderer*` that needs to
be passed to the drawing functions like `set_draw_color`, and the
`context` value that was given to `graphics_render`; if you need to store
variables between subsequent frames, this is where you can put
them. The third argument to `renderframe` are the current window dimensions.

If `renderframe` returns `true`, the image is drawn and
`renderframe` is called again 1/60 seconds later. If it returns
`false`, the drawing stops, the window is closed, and
`graphics_render` returns.

## set_draw_color {#one_set_draw_color}

```C
void set_draw_color(SDL_Renderer* renderer, Color color)
```

Set the drawing color that the `SDL_Renderer` should use for future
drawing.

## clear_SDL_Renderer {#one_clear_SDL_Renderer}

```C
void clear_SDL_Renderer(SDL_Renderer* renderer)
```

Clear the rendering area, i.e. fill it with the current drawing
color.

Note that you can use the generic `clear` as a shortcut.

## draw_rect {#one_draw_rect}

```C
void draw_rect(SDL_Renderer* renderer, Rect2(float) r)
```

Draw the given empty rectangle with the current colors.

## draw_fill_rect {#one_draw_fill_rect}

```C
void draw_fill_rect(SDL_Renderer* renderer, Rect2(float) r)
```

Draw the given filled rectangle with the current colors.

## draw_fill_rects {#one_draw_fill_rects}

```C
void draw_fill_rects(SDL_Renderer* renderer, slice(Rect2(float)) rects)
```

Draw the given filled rectangles with the current colors.

## draw_circle {#one_draw_circle}

```C
void draw_circle(SDL_Renderer* renderer, Vec2(int) pos, int radius)
```

Draw the given circle with the current colors.

## draw_fill_circle {#one_draw_fill_circle}

```C
void draw_fill_circle(SDL_Renderer* renderer, Vec2(int) pos, int radius)
```

Draw the given circle with the current colors.

## draw_points_int {#one_draw_points_int}

```C
void draw_points_int(SDL_Renderer* renderer, slice(Vec2(int)) points)
```

Draw the given points.

## draw_points_float {#one_draw_points_float}

```C
void draw_points_float(SDL_Renderer* renderer, slice(Vec2(float)) points)
```

Draw the given points (at subpixel precision).

## draw_line {#one_draw_line}

```C
void draw_line(SDL_Renderer *rdr, Vec2(float) from, Vec2(float) to)
```

Draw a line from `from`, to `to` (at subpixel precision).

## draw_lines {#one_draw_lines}

```C
void draw_lines(SDL_Renderer *renderer, slice(Vec2(float)) lines)
```

Draw a series of connected lines on the current rendering target
(at subpixel precision).

## get_Surface_from_Window {#one_get_Surface_from_Window}

```C
SDL_Surface* get_Surface_from_Window(SDL_Window *window)
```

Original docs:

Returns the surface associated with the window.

A new surface will be created with the optimal format for the
window, if necessary. This surface will be freed when the window
is destroyed. Do not free this surface.

You may not combine this with 3D or the rendering API on this
window.

## vertex_3 {#one_vertex_QthreeE}

```C
Vertex vertex_3(Vec2(float) position, SDL_Color color, Vec2(float) texture_position)
```

Constructor for a Vertex with full information.

## vertex_2 {#one_vertex_QtwoE}

```C
Vertex vertex_2(Vec2(float) position, SDL_Color color)
```

Constructor for a SDL_Vertex with texture position set to (0,0)
(e.g. for when not using textures).

## new_VertexRenderer {#one_new_VertexRenderer}

```C
VertexRenderer new_VertexRenderer()
```

Create a new `VertexRenderer`.

## drop_VertexRenderer {#one_drop_VertexRenderer}

```C
void drop_VertexRenderer(VertexRenderer self)
```

Drop a `VertexRenderer`.

## push_vertex {#one_push_vertex}

```C
int push_vertex(VertexRenderer *rdr, Vertex v)
```

Push one new vertex to the `VertexRenderer`, without registering
the vertex for rendering. Returns the index to the newly pushed
vertex; to register it for rendering, pass that index as part of a
triple of indices to `push_triangle`.

## push_triangle {#one_push_triangle}

```C
void push_triangle(VertexRenderer *rdr, Vec3(int) indices)
```

Push a triangle to the `VertexRenderer`, consisting of the indices
to vertices that were pushed before using `push_vertex`.

## render_VertexRenderer {#one_render_VertexRenderer}

```C
void render_VertexRenderer(SDL_Renderer *renderer, VertexRenderer *rdr)
```

Render the `VertexRenderer` to the given `SDL_Renderer`. The
`VertexRenderer` is not consumed or cleared.

## clear_VertexRenderer {#one_clear_VertexRenderer}

```C
void clear_VertexRenderer(VertexRenderer *rdr)
```

Clear the `VertexRenderer`, so that it can be re-used.

## new_Texture_from_Surface {#one_new_Texture_from_Surface}

```C
Texture new_Texture_from_Surface(SDL_Renderer * renderer,
                                 SDL_Surface * surface)
```

Original docs:

Create a texture from an existing surface.

The surface is not modified or freed by this function.

The SDL_TextureAccess hint for the created texture is
SDL_TEXTUREACCESS_STATIC.

The pixel format of the created texture may be different from the
pixel format of the surface. Use SDL_QueryTexture() to query the
pixel format of the texture.

## create_Texture {#one_create_Texture}

```C
Texture create_Texture(SDL_Renderer * renderer,
                       Uint32 format,
                       int access,
                       Vec2(int) dimensions)
```

Create a texture for a rendering context.

format: 	one of the enumerated values in SDL_PixelFormatEnum

access: 	one of the enumerated values in SDL_TextureAccess

Aborts with an error message if no rendering context was active,
the format was unsupported, or the width or height were out of
range.

Also aborts if `dimensions` contains negative values.

## update_Texture {#one_update_Texture}

```C
void update_Texture(Texture *self,
                    Option(Rect2(int)) rect,
                    const void *pixels, // ugh
                    // why is pitch not in configuration? OK, pixels
                    // specific
                    int pitch)
```

Update the given texture rectangle with new pixel data.

rect: 	an SDL_Rect structure representing the area to update, or NULL to update the entire texture
pixels: 	the raw pixel data in the format of the texture
pitch: 	the number of bytes in a row of pixel data, including padding between lines

NOTE that pitch is in bytes, not pixels! This function is unsafe
because it has to handle various pixel formats.

(Todo: could it calculate pitch from metainformation, though?)

## render_Texture {#one_render_Texture}

```C
void render_Texture(SDL_Renderer *renderer,
                    Texture *texture,
                    Option(Rect2(int)) src,
                    Option(Rect2(int)) dst)
```

Copy a portion of the texture to the current rendering target.

## draw_fill_ellipsoid {#one_draw_fill_ellipsoid}

```C
void draw_fill_ellipsoid(VertexRenderer* rdr,
                         Rect2(float) bounds,
                         Option(Vec2(float)) angle_from_to,
                         float hole, /* 0..1 */
                         float turnangle,
                         SDL_Color color,
                         u8 num_segments)
```

Draw the given ellipsoid with the given color onto the given
`VertexRenderer`, which is *not* cleared. The ellipsoid is positioned and
shaped so as to fit perfectly into `bounds`, before turning the result for
the given `turnangle` in radians (`0` .. `2 * math_pi`). `angle_from_to` are
the angles from which and to the circle should be drawn, if you want just a
slice (again in radians, in the shape before it is turned by
`turnangle`). `hole` determines how large of a hole is left in the center,
0. meaning none, 1. meaning the hole is as large as the whole ellipsoid.
`num_segments` gives the number of segments used for a full circle/ellipsoid;
a value of about 20 is recommended (more segments may make drawing slower).

(Uses subpixel precision.)

See [examples/draw_circle.c](../examples/draw_circle.c) for an example.

# Generic functions

## to_sdl {#two_to_sdl}

```C
to_sdl(v)
```

Convert a value of a type from cjmath.h into a type from SDL.h

Members:

```C
Rect2(float) : SDL_FRect to_sdl_Rect2_float(Rect2(float) r);
Rect2(int)   : SDL_Rect to_sdl_Rect2_int(Rect2(int) r);
Vec2(float)  : SDL_FPoint to_sdl_Vec2_float(Vec2(float) self);
Vec2(int)    : SDL_Point to_sdl_Vec2_int(Vec2_int self);
```

## asserting_sdl {#two_asserting_sdl}

```C
asserting_sdl(v)
```

Assert that the return value of a function from the SDL2 libray
does not represent an error. If it is an error, print the SDL
error message and abort. Otherwise, return the value.

Members:

```C
SDL_Surface * : SDL_Surface* asserting_sdl_pointer_SDL_Surface(SDL_Surface* p);
SDL_Texture * : SDL_Texture* asserting_sdl_pointer_SDL_Texture(SDL_Texture* p);
int           : int asserting_sdl_int(int code);
```

# Macros

## Texture {#three_Texture}

```C
Texture(sdltexture)
```

Create a Texture from an existing SDL_Texture pointer, taking
ownership.

## ColorA {#three_ColorA}

```C
ColorA(red, green, blue, strength)
```

Create a `SDL_Color`

<hr>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
