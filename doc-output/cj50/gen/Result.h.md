<!-- THIS FILE WAS AUTO-GENERATED by gendoc. DO NOT EDIT! -->


A Result is a value that has two variants and can represent either
success with a value of one type, `T`, or an error with an error
value of another type, `E`. It has a field `is_ok` that is `true`
if the Result represents success, in which case the field `ok` is
valid, otherwise the field `err` is valid.

```C
typedef struct Result(T, E) {
    bool is_ok;
    union {
        T ok;
        E err;
    };
} Result(T, E);
```

# Macros

## Result

```C
Result(T, E) XCAT(Result_, XCAT(T, XCAT(__, E)))
```

This macro creates a type name for a `Result` specific for the
given type names `T` and `E`.

Implementation wise, it simply concatenates `Result_`, `T`, `__`,
`E`. For this reason, the type names `T` and `E` must not contain
spaces, e.g. `unsigned int` would not work and a typedef like
`uint` has to be used instead.

## Ok

```C
Ok(T, E)
```

Returns the constructor function for the `ok` variant of the `Result(T, E)` type for the given `T` and `E` types. Usage example:

```C
Ok(int, cstr)(42)
```

## Err

```C
Err(T, E)
```

Returns the constructor function for the `err` variant of the `Result(T, E)` type for the given `T` and `E` types. Usage example:

```C
Err(int, cstr)("the input does not contain a number")
```

## if_let_Ok

```C
if_let_Ok(decl, expr)
```

This macro allows for convenient matching and conditional
execution depending on what case of the Result was
received. CAREFUL: it must always be paired with `else_Err` and
`end_let_Ok`, or weird syntax errors will be reported because
curly braces will not be balanced!

```C
if_let_Ok(String cnt, filecontents_String(path)) {
    print(cnt);
    drop(cnt);
} else_Err(SystemError e) {
    fprintln_SystemError(stderr, e);
} end_let_Ok;
```

<hr>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
