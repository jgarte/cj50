<!-- THIS FILE WAS AUTO-GENERATED by gendoc. DO NOT EDIT! -->


The `cj50/gen/Vec` library is implementing vectors (mutable
ordered collections with O(1) access and ability to change size at
the end) and slices (immutable collections with O(1) read access)
parameterized with the item type, and is implemented in the following
files:

* `cj50/gen/Vec.h` (main file, non-parameterized parts)
* [`cj50/gen/template/Vec.h`](template/Vec.h.md) (parameterized parts instantiated once per Vec)
* [`cj50/gen/template/slices.h`](template/slices.h.md) (parameterized parts instantiated  for slice, mutslice)
* [`cj50/gen/template/vectorlikes.h`](template/vectorlikes.h.md) (parameterized parts instantiated for Vec, slice, mutslice)

Vectors and slices are related: a `Vec` is an owned data structure
(it must reside in exactly one place at any time), whereas both
`slice` and its mutable sibling `mutslice` are borrowed (they must
only be used as long as the holder of the storage, either a `Vec`,
or static storage (which exists for the duration of the program
and hence is unproblematic), is available). `Vec` allows both
replacing existing elements, as well as changing its size (via
`push` and `pop` and (in the future) other functions), which is
only allowed when there are no `slices` of it in use. `mutslice`
can only be borrowed from `Vec` (not constant storage), and allows
replacing its elements, which replaces them for the `Vec` they are
borrowed from, too; but it cannot change size (there are no `push`
or similar operations). `slice` cannot be modified at all, but in
exchange any number of `slice`s can exist at the same time as long
as there is no `mutslice` and `Vec` is left untouched.

Vectors and slices are cj50's replacement for pointers to arrays
which are the basic building blocks for sequences of items in C,
but which are prone to mistaken use. The vectors and slices here
are very closely modelled after their counterparts in Rust.

# Types

## VecError {#zero_VecError}

```C
typedef struct VecError {
    uint8_t code;
} VecError
```

A type indicating an error handling Vec. The instances are:

    VecError_out_of_capacity

# Normal functions

## equal_VecError {#one_equal_VecError}

```C
bool equal_VecError(const VecError *a, const VecError *b)
```

Check equivalence.

## print_debug_VecError {#one_print_debug_VecError}

```C
int print_debug_VecError(const VecError *e)
```

Print in C code syntax.

## fprintln_VecError {#one_fprintln_VecError}

```C
int fprintln_VecError(FILE *out, const VecError *e)
```

Print for program user.

## max_size_t {#one_max_size_t}

```C
size_t max_size_t(size_t a, size_t b)
```

Return the larger of the two arguments.

# Macros

## DEF_SLICE {#three_DEF_SLICE}

```C
DEF_SLICE(T, var, ...)
```

Create a slice with its storage on the stack.

Example:

```C
DEF_SLICE(ColorFunction_float, sl, {
    { color(255, 0, 0), f },
    { color(0, 255, 0), g }
});
```

## SLICE_FROM_ARRAY {#three_SLICE_FROM_ARRAY}

```C
SLICE_FROM_ARRAY(var)
```

Create a slice from an array variable with static size.

NOTE: requires up to date `new_slice` generic.

Example:

```C
ColorFunction_float fs[] = {
    { color(240, 220, 0), f }
};

foo(SLICE_FROM_ARRAY(fs));
```

## SLICE_FROM_ARRAY_OF_T {#three_SLICE_FROM_ARRAY_OF_T}

```C
SLICE_FROM_ARRAY_OF_T(T, var)
```

Create a slice from an array variable with static size.

(Does not require `new_slice` generic, but needs type name
argument.)

Example:

```C
ColorFunction_float fs[] = {
    { color(240, 220, 0), f }
};

foo(SLICE_FROM_ARRAY_OF_T(ColorFunction_float, fs));
```

<hr>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
