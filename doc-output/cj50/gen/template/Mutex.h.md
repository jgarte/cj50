<!-- THIS FILE WAS AUTO-GENERATED by gendoc. DO NOT EDIT! -->


A `Mutex` embeds a value of type `T`, and protects access to it,
so that only one thread ever accesses it at the same time.

Example:

# Types

## Mutex {#zero_Mutex}

```C
typedef struct Mutex(T)
```

```C
#include <cj50.h>
#include <cj50/instantiations/Mutex_int.h>

void* thread_run(void *arg) {
    Mutex(int) *ms = arg;
    for (size_t i = 0; i < 1000000; i++) {
        MutexGuard(int) gs = lock_Mutex_int(ms);
        (*deref_mut_MutexGuard_int(&gs))++;
        drop_MutexGuard_int(gs);
    }
    return NULL;
}

int main() {
    __CJ50_Mutex_debug = env_is_true("CJ50_DEBUG"); // implied if using MAIN macro
    
    Mutex(int) ms = new_Mutex_int(0);

    Thread t1 = unwrap_Result_Thread__SystemError(
        spawn_thread(thread_run, &ms, String("t1")));
    Thread t2 = unwrap_Result_Thread__SystemError(
        spawn_thread(thread_run, &ms, String("t2")));

    unwrap_Result_ref_void__SystemError(join_Thread(t1));
    unwrap_Result_ref_void__SystemError(join_Thread(t2));

    MutexGuard(int) gs = lock_Mutex_int(&ms);
    assert(*deref_mut_MutexGuard_int(&gs) == 2000000);
    drop_MutexGuard_int(gs);
}
```

# Normal functions

## new_Mutex_$T {#one_new_Mutex_QDT}

```C
Mutex(T) new_Mutex_$T(T val)
```

Create a new mutex, protecting `val`. `val` should be an owned
type, to be owned by the `Mutex`, so that it can only be accessed
via `lock` (and then `deref` or `deref_mut`), to prevent
accidental modification without holding the lock.

## lock_Mutex_$T {#one_lock_Mutex_QDT}

```C
MutexGuard(T) lock_Mutex_$T(Mutex(T) *self)
```

Lock the mutex (blocking the current thread if the `Mutex` is
currently locked by another thread), returning a `MutexGuard` that
can hand out a reference to the data via the deref* functions. The
lock is released via `drop`.

If the __CJ50_Mutex_debug gloal variable is true, which is
automatically the case if the `MAIN` macro is used and the
`CJ50_DEBUG` environment variable is true at program start time,
the `MutexGuard` embeds a small allocation so that when forgetting
to drop, the address sanitizer or Valgrind will report on that
fact.

The `MutexGuard` is only valid as long as the `Mutex` it is based on
exists.

## deref_MutexGuard_$T {#one_deref_MutexGuard_QDT}

```C
const T* deref_MutexGuard_$T(const MutexGuard(T) *self)
```

Get read-only access to the data that is protected by the `Mutex`
that the `MutexGuard` is based on. The returned reference is only
valid as long as the `MutexGuard` is not dropped.

## deref_mut_MutexGuard_$T {#one_deref_mut_MutexGuard_QDT}

```C
T* deref_mut_MutexGuard_$T(const MutexGuard(T) *self)
```

Get mutable access to the data that is protected by the `Mutex`
that the `MutexGuard` is based on. The returned reference is only
valid as long as the `MutexGuard` is not dropped.

<hr>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
