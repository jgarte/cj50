<!-- THIS FILE WAS AUTO-GENERATED by gendoc. DO NOT EDIT! -->


An Option is a type that may sometimes represent some value, and
sometimes no value. Each Option type is specialized for the type of
the value that it may contain. For this reason, the type of that
contained value has to be specified as parameter to `Option`.

An Option has a field `is_some` which specifies whether the Option
value contains a value, in which case the field is `true`, or not (the
`none` case), and a field `value` which contains the actual value if
present (reading the `value` field while `is_some` is `false` is
undefined behaviour, don't do that!). It is the following struct, with
`T` replaced with the type passed to `Option(T)`:

```C
typedef struct Option(T) {
    bool is_some;
    T value;
} Option(T);
```

Member functions for the following generic functions are also defined:

`some(val)`
: Returns an Option where the `is_some` field is set to `true` and the `value` field is set to `val`.

`none(T)`
: Returns an Option where the `is_some` field is set to `false`. The `value` field is not valid. Also see `NONE` macro.

`drop(opt)`
: Calls `drop` on the value in the `value` field if `is_some` is `true`. CAUTION: only call drop when value has not been moved!

`equal(opt1, opt2)`
: Returns `true` if both arguments are structurally equivalent.

`unwrap(opt)`
: Returns the contents of the `value` field if `is_some` is `true`, otherwise aborts the program.

`print_debug(&opt)`
: Print a programmer's view of the Option value, given by reference.

`print_debug_move(opt)`
: Print a programmer's view of the Option value, given by copy.


# Macros

## Option {#three_Option}

```C
Option(T) Option_$T
```

This macro creates a type name for an `Option` specific for the
given type name `T`.

Implementation wise, it simply concatenates `ref_` and the given
type name. For this reason, the type name `T` must not contain
spaces or `*`, e.g. `unsigned int` would not work and a typedef
like `uint` has to be used instead. For handling references, see
the `ref(T)` type generator.

## GENERATE_Option {#three_GENERATE_Option}

```C
GENERATE_Option(T)
```

This macro defines the struct and functions to implement the type
`Option(T)`. It has to be used once for a given type
`T`. Afterwards `Option(T)` can be used any number of times.

## NONE {#three_NONE}

```C
NONE
```

This macro is a short cut for `none(T)` but can only be used in
variable assignment, e.g.:

```C
Option(float) x = NONE;
```

It cannot be used in a function call like `f(NONE)`, instead
`f(none(float))` has to be used.

## Some {#three_Some}

```C
Some(T) some_$T
```

The constructor for some value of `T`. Example.

```C
    return Some(cstr)("foo")
```

NOTE: only works if T is known textually
(e.g. `None(typeof(somevar))` does not work, while
`none(typeof(somevar))` does).

## None {#three_None}

```C
None(T)
```

```C
    return None(cstr);
```

NOTE: only works if T is known textually
(e.g. `None(typeof(somevar))` does not work, while
`none(typeof(somevar))` does). The advantage over `none` is that
the latter is a generic that currently must be updated manually
and might be outdated or not in scope yet (within files of cj50
itself).

## if_let_Some {#three_if_let_Some}

```C
if_let_Some(var, expr)
```

This macro allows for convenient matching and conditional
execution depending on what case of the Option was
received. CAREFUL: it must always be paired with `else_None`, or
weird syntax errors will be reported because curly braces will not
be balanced! (The `else_None` always has to be there, but the `{
}` after it are optional.)

`var` is introduced in the given scope `{ .. }`. Note that you
don't need to specify a type for `var`, it is derived
automatically.

```C
if_let_Some(w, get_float()) {
    if_let_Some(h, get_float()) {
        println(w * h);
    } else_None {
        goto cancelled;
    }
} else_None {
    goto cancelled;
}
```

## while_let_Some {#three_while_let_Some}

```C
while_let_Some(var, expr)
```

Convenient conditional loop macro.

`var` is introduced in the given scope `{ .. }`. Note that you
don't need to specify a type for `var`, it is derived
automatically. You can't specify `UNUSED`, although you can pass
the variable to `drop` to silence the warning.

```C
while_let_Some(v, pop(&vec)) {
    DBG(v);
}
```

## LET_Some_ELSE {#three_LET_Some_ELSE}

```C
LET_Some_ELSE(var, expr)
```

Set `var` to the value if `expr` evaluated to Some, otherwise run
the (statement or) block that is following.

The following example prints `x`.

```C
LET_Some_ELSE(b1, some('x')) {
    RETURN_Ok(None(u32));
}
print(b1);
```

<hr>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
