<!-- THIS FILE WAS AUTO-GENERATED by gendoc. DO NOT EDIT! -->

# Types

## String {#zero_String}

```C
typedef struct String {
    Vec(char) vec;
} String
```

`String` is an owned, mutable type that holds a string of
characters, more precisely, an array of bytes, that represents a
text in UTF-8 encoding. Unlike C strings (see `CStr`), it does not
use a '\0' terminator, and can represent embedded '\0'
characters. It automatically resizes itself as needed to accept
additional text that is added.

It is implemented as a wrapper around `Vec(char)`. It adds the
guarantee that the contents is in correct UTF-8 encoding.

## strslice {#zero_strslice}

```C
typedef struct strslice {
    slice(char) slice;
} strslice
```

`strslice` is a borrowed, immutable type that, just like `String`,
holds a string of characters, more precisely, an array of bytes,
that represents a text in UTF-8 encoding.

It is implemented as a wrapper around `slice(char)`. It adds the
guarantee that the contents is in correct UTF-8 encoding.

# Normal functions

## deref_String {#one_deref_String}

```C
strslice deref_String(const String *s)
```

Get the string slice of the whole String.

## clear_String {#one_clear_String}

```C
void clear_String(String *s)
```

Clear the string, removing all characters.

Note that this method has no effect on the allocated capacity of
the String.

## new_String {#one_new_String}

```C
String new_String()
```

Create a new empty String.

## with_capacity_String {#one_with_capacity_String}

```C
String with_capacity_String(size_t capacity)
```

Create a String with the given `capacity` (but 0 current length).

## len_strslice {#one_len_strslice}

```C
size_t len_strslice(const strslice *s)
```

The length in *bytes*, not characters. This operation is fast (has
a constant cost), unlike `strlen` for C strings.

## len_String {#one_len_String}

```C
size_t len_String(const String *s)
```

The length in *bytes*, not characters. This operation is fast (has
a constant cost), unlike `strlen` for C strings.

## push_String {#one_push_String}

```C
void push_String(String *s, char c)
```

Appends the given char to the end of this String.

## append_String_String {#one_append_String_String}

```C
void append_String_String(String *a, String *b)
```

Appends the given String `b` to the end of String `a`, emptying
`b`.

## append_move_String_String {#one_append_move_String_String}

```C
void append_move_String_String(String *a, String b)
```

Appends the given String `b` to the end of String `a`, consuming
`b`.

## cstr_String {#one_cstr_String}

```C
Option(cstr) cstr_String(String *s)
```

Get `s` as a C string, if possible--it's only possible if there
are no embedded `'\0'` characters.

The returned `cstr` is borrowed and shares storage with `s`, so
`s` may not be mutated while the `cstr` is in use.

## unsafe_slice_of_String {#one_unsafe_slice_of_String}

```C
strslice unsafe_slice_of_String(const String *s, Range range)
```

Get a slice of the string. Note that the given range of indices
must be in byte positions, not unicode codepoints. No check is
done that the given positions are at UTF-8 boundaries. Aborts for
invalid indices. (Only use if sure about the indices, otherwise
use `get_slice_of_String`.)

<hr>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
