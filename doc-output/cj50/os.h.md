<!-- THIS FILE WAS AUTO-GENERATED by gendoc. DO NOT EDIT! -->


Wrappers around C library and POSIX functions using `Result`
instead of the traditional combination of in-band error signalling
and `errno`.

# Types

## OsError {#zero_OsError}

```C
typedef struct OsError {
    // Rust uses i32 for RawOsError, why? I only see u8 being used or
    // so. But let's not diverge.
    int32_t number; // can't use `errno` because that's a macro
} OsError
```

`OsError` represents an operating system error; it is holding an
error nummer, which is traditionally stored in the `errno` global
variable.

## SystemError {#zero_SystemError}

```C
typedef struct SystemError {
    syscallInfoId_t syscallinfo_id;
    OsError oserror;
} SystemError
```

A SystemError contains the name of the system call that failed,
and the system error.

## CFile {#zero_CFile}

```C
typedef struct CFile {
    FILE *ptr;
} CFile
```

An owned type holding a C library `FILE*` type. The contained
pointer is never `NULL` except after calling `close_File`.

# Normal functions

## equal_CFile {#one_equal_CFile}

```C
bool equal_CFile(const CFile *a, const CFile *b)
```

Equality on CFile does not make much sense; it does report whether
the embedded `FILE*` pointers are identical.

## drop_CFile {#one_drop_CFile}

```C
void drop_CFile(CFile f)
```

Closes the file.

This does not report errors (except it does print a warning),
because the drop interface can't, except via abort. This is
exactly like in Rust. IIRC the conclusion there was that modern
systems don't ever report errors on `close` any more, except
perhaps some networked file systems like NFS or wrongly made fuse
file systems. To be sure that there was no problem writing, either
call `fclose(f.ptr)` or `flush(&f)` and handle the errors
there. (Also, `sync(&f)`.)

## os_getc_unlocked {#one_os_getc_unlocked}

```C
Result(Option(u8), SystemError) os_getc_unlocked(CFile *inp)
```

Returns a single byte from the input, if possible; at EOF (end of
file), returns Ok(None). `inp` must previously have been locked
using `flockfile` and afterwards unlocked using `funlockfile` (see
`man 3 flockfile`).

## open_CFile {#one_open_CFile}

```C
Result(CFile, SystemError) open_CFile(cstr pathname, cstr mode)
```

Opens the file whose name is the string pointed to by `pathname` and
associates a stream with it.

For details, including the meaning of `mode`, see `man 3 fopen`.

## memopen_CFile {#one_memopen_CFile}

```C
Result(CFile, SystemError) memopen_CFile(void *buf, size_t size, cstr mode)
```

Opens a stream that permits the access specified by mode.  The
stream allows I/O to be performed on the string or memory buffer
pointed to by buf.

For details, see `man 3 fmemopen`.

## flush_CFile {#one_flush_CFile}

```C
Result(Unit, SystemError) flush_CFile(CFile *f)
```

For output streams, forces a write of all user-space buffered data
for the given output.

For input streams associated with seekable files (e.g., disk
files, but not pipes or terminals), discards any buffered data
that has been fetched from the underlying file, but has not been
consumed by the application.

The open status of the stream is unaffected.

## sync_CFile {#one_sync_CFile}

```C
Result(Unit, SystemError) sync_CFile(CFile *f)
```

Transfers ("flushes") all modified in-core data of (i.e., modified
buffer cache pages for) the file referred to by the file
descriptor fd to the disk device (or other permanent storage de‚Äê
vice) so that all changed information can be retrieved even if the
system crashes or is rebooted.  This includes writing through or
flushing a disk cache if present.  The call blocks until the
device reports that the transfer has completed.

As well as flushing the file data, also flushes the
metadata information associated with the file (see inode(7)).

## close_CFile {#one_close_CFile}

```C
Result(Unit, SystemError) close_CFile(CFile *f)
```

Close the file. Marks `f` so that the embedded `FILE*` pointer is
`NULL`. It is safe to call `drop` afterwards, but any other
function will segfault (NULL pointer dereference)!

<hr>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
