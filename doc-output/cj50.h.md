<!-- THIS FILE WAS AUTO-GENERATED by gendoc. DO NOT EDIT! -->

This is the main header file of the cj50 library collection.

It includes the various other files (see the [documentation
index](index.md)), and additionally provides the utilities
described below. Besides additional functions and macros, it
defines a number of generic functions that dispatch to functions
from various other files.

# Type aliases

## ParseError

```C
typedef uint16_t ParseError
```

Values of this type (a number) describe the reason why a string
does not contain text that properly represents a value that the
used parse function should return.

Currently, numbers in the range 1..255 represent errors defined by
the operating system (errno), numbers in the range 500..29999 are
specific to cj50.h. But do *not* rely on any details of this type,
they may change, values of this type should just be passed to one
of the functions that accept it (`string_from_ParseError` and
`print_ParseError`).

# Normal functions

## get_string

```C
Option(string) get_string()
```

Read a string from standard input, terminated by a
newline. Returns none on end of file (when ctl-d is pressed).

## string_from_ParseError

```C
char* string_from_ParseError(ParseError e)
```

Convert a `ParseError` value into a `string` for display. The
receiver owns the returned string.

## parse_int

```C
Result(int, ParseError) parse_int(string s)
```

Translate a string into an `int` if possible.

## get_int

```C
Option(int) get_int()
```

Read an integer number from standard input, terminated by a
newline. Returns none on end of file (when ctl-d is pressed).

## parse_nat

```C
Result(int, ParseError) parse_nat(string s)
```

Translate a string into an `int` in the natural number range (1 or
higher) if possible.

## get_nat

```C
Option(int) get_nat()
```

Read a natural number from standard input, terminated by a
newline. Returns none on end of file (when ctl-d is pressed).

## parse_nat0

```C
Result(int, ParseError) parse_nat0(string s)
```

Translate a string into an `int` in the natural number range
including 0 (0 or higher) if possible.

## get_nat0

```C
Option(int) get_nat0()
```

Read a natural number or zero from standard input, terminated by a
newline. Returns none on end of file (when ctl-d is pressed).

## parse_float

```C
Result(float, ParseError) parse_float(string s)
```

Translate a string into an `float` if possible.

## get_float

```C
Option(float) get_float()
```

Read a floating point number or zero from standard input,
terminated by a newline. Returns none on end of file (when ctl-d is
pressed).

## new_chars

```C
char* new_chars(size_t len)
```

Allocate and return a new array of `len` char values. Aborts
when there is not enough memory (never returns the NULL
pointer). The slots in the returned array are all initialized to
the '\0' char. This is the same as `new_string`.

## new_string

```C
static UNUSED
string new_string(size_t len)
```

Allocate and return a new string of capacity `len`. Aborts when
there is not enough memory (never returns the NULL pointer). The
string is set to the empty string. This is the same as
`new_chars`.

## new_strings

```C
string* new_strings(size_t len)
```

Allocate and return a new array of `len` string values. Aborts
when there is not enough memory (never returns the NULL
pointer). The slots in the returned array are all initialized to
the NULL pointer.

## new_ints

```C
int* new_ints(size_t len)
```

Allocate and return a new array of `len` int values. Aborts when
there is not enough memory (never returns the NULL pointer). The
slots in the returned array are all initialized to the value 0.

## new_floats

```C
float* new_floats(size_t len)
```

Allocate and return a new array of `len` float values. Aborts when
there is not enough memory (never returns the NULL pointer). The
slots in the returned array are all initialized to the value 0.

# Generic functions

## print

```C
print(v)
```

Prints the given value for normal text use.

Returns an `int` that when negative signifies an error (check
`errno` for the error in this case), and when positive signifies
the number of bytes written.

Also see `print_debug` and `print_debug_array`, which support more
types, but are not meant for printing output for normal humans.

Members:

```C
char   : int putchar(int c);
char*  : int print_string(const_string str);
double : int print_double(double x);
float  : int print_float(float x);
int    : int print_int(int n);
u64    : u64 print_u64(u64 n);
uint   : int print_uint(uint n);
```

## println

```C
println(v)
```

Prints the given value for normal text use, followed by a newline
("\n") for convenience.

Members:

```C
char   : int println_char(char v);
char*  : int println_string(string v);
double : int println_double(double v);
float  : int println_float(float v);
int    : int println_int(int v);
u64    : int println_u64(u64 v);
uint   : int println_uint(uint v);
```

## print_debug

```C
print_debug(v)
```

Prints the given value in a programmer's view, for debugging
purposes.

Returns an `int` that when negative signifies an error (check
`errno` for the error in this case), and when positive signifies
the number of bytes written.

See `print` for printing as normal text, not for debugging, and
`print_debug_array` for printing arrays.

Members:

```C
Line2                       : int print_debug_Line2(Line2 s);
Option(float)               : int print_debug_move_Option_float(const Option_float s);
Option(float)*              : int print_debug_Option_float(const Option_float *s);
Option(int)                 : int print_debug_move_Option_int(const Option_int s);
Option(int)*                : int print_debug_Option_int(const Option_int *s);
Option(string)              : int print_debug_move_Option_string(const Option_string s);
Option(string)*             : int print_debug_Option_string(const Option_string *s);
Rect2                       : int print_debug_Rect2(Rect2 s);
Result(int, ParseError)     : int print_debug_move_Result_int__ParseError( const Result_int__ParseError s);
Result(int, ParseError)*    : int print_debug_Result_int__ParseError( const Result_int__ParseError *s);
Result(string, SystemError) : int print_debug_move_Result_string__SystemError( const Result_string__SystemError s);
SystemError                 : int print_debug_SystemError(const SystemError v);
Vec2                        : int print_debug_Vec2(Vec2 a);
Vec3                        : int print_debug_Vec3(Vec3 a);
bool                        : int print_debug_bool(bool v);
char                        : int print_debug_char(char c);
char*                       : int print_debug_string(const_string str);
double                      : int print_double(double x);
float                       : int print_float(float x);
int                         : int print_int(int n);
u64                         : u64 print_u64(u64 n);
uint                        : int print_uint(uint n);
```

## print_debug_array

```C
print_debug_array(v, len)
```

Prints the given array in a programmer's view, for debugging
purposes.

Returns an `int` that when negative signifies an error (check
`errno` for the error in this case), and when positive signifies
the number of bytes written.

See `print_debug` for printing non-array values.

Members:

```C
char*   : int print_debug_chars(const char* ary, size_t len);
float*  : int print_debug_floats(const float* ary, size_t len);
int*    : int print_debug_ints(const int* ary, size_t len);
string* : int print_debug_strings(const string* ary, size_t len);
```

## resize

```C
resize(v, oldlen, newlen)
```

Expects an array as the first argument, and the current length of
the array and the desired new length. Returns a new array of the
desired new length. If the new length is shorter than the old
length, the slots that are freed are `drop`ped, if the new length
is larger, then the new slots are filled in with blanks (zero
values, NULL pointers, or similar).

Members:

```C
float*  : float* resize_floats(float* ary, size_t oldlen, size_t newlen);
int*    : int* resize_ints(int* ary, size_t oldlen, size_t newlen);
string* : string* resize_strings(string* ary, size_t oldlen, size_t newlen);
```

## drop

```C
drop(v)
```

Frees the resources held by the given value (including resources
held by contained values, recursively, unlike the `free` function).

Members:

```C
Option(double) : inline void drop_Option_double(const Option_double s);
Option(float)  : inline void drop_Option_float(const Option_float s);
Option(int)    : inline void drop_Option_int(const Option_int s);
Option(string) : inline void drop_Option_string(const Option_string s);
Vec2*          : void free(void *ptr);
Vec3*          : void free(void *ptr);
char*          : void drop_string(string s);
float*         : void free(void *ptr);
int*           : void free(void *ptr);
```

## drop_array

```C
drop_array(v, len)
```

Frees the resources held by the given array,
including all the values contained in the array (including
resources held by contained values, recursively). For arrays
holding pointers, array slots containing the NULL pointer are
skipped.

Members:

```C
string* : void drop_strings(string* ary, size_t len);
```

## equal

```C
equal(a, b)
```

Takes two values of the same type and returns a `bool`. Returns
`true` if `a` and `b` are structurally equivalent.

Members:

```C
Option(float)*               : bool equal_Option_float(const Option_float *a, const Option_float *b);
Option(int)*                 : bool equal_Option_int(const Option_int *a, const Option_int *b);
Option(string)*              : bool equal_Option_string(const Option_string *a, const Option_string *b);
Result(int, ParseError)*     : bool equal_Result_int__ParseError(const Result_int__ParseError *a, const Result_int__ParseError *b);
Result(string, SystemError)* : bool equal_Result_string__SystemError(const Result_string__SystemError *a, const Result_string__SystemError *b);
bool                         : bool equal_move_bool(const bool a, const bool b);
bool*                        : bool equal_bool(const bool *a, const bool *b);
char                         : bool equal_move_char(const char a, const char b);
double                       : bool equal_move_double(const double a, const double b);
double*                      : bool equal_double(const double *a, const double *b);
float                        : bool equal_move_float(const float a, const float b);
float*                       : bool equal_float(const float *a, const float *b);
int                          : bool equal_move_int(const int a, const int b);
int*                         : bool equal_int(const int *a, const int *b);
string                       : bool equal_move_string(const char *a, const char *b);
string*                      : bool equal_string(const string *a, const string *b);
```

## some

```C
some(v)
```

Takes a value of some type `T` and returns a `some` variant of
`Option(T)` containing the value.

Members:

```C
double : Option_double some_double(const double val);
float  : Option_float some_float(const float val);
int    : Option_int some_int(const int val);
string : Option_string some_string(const string val);
u64    : Option_u64 some_u64(const u64 val);
```

## none

```C
none(T)
```

Returns the none variant of `Option(T)` for the given
T. Equivalent to `none_T()` using the type name of T, but
`none(T)` allows T to also be a `typeof` expression.

Members:

```C
double : Option_double none_double();
float  : Option_float none_float();
int    : Option_int none_int();
string : Option_string none_string();
u64    : Option_u64 none_u64();
```

## unwrap

```C
unwrap(v)
```

Takes a wrapper for some type `T` (like `Option(T)`, or `Result(T,
E)`) and returns the contained value of type `T` if possible, or
aborts if not possible.

Example:

```C
Option(string) maybe_name = get_string();
// maybe_name can be a `none(string)` or e.g. `some("Alex")`.
string name = unwrap(maybe_name);
// Now we're guaranteed to have a string in `name`, "Alex" if we
// had the second case above. But if `maybe_name` was a none
// then the program has terminated by now instead.
```

Members:

```C
Option(double)              : double unwrap_Option_double(const Option_double s);
Option(float)               : float unwrap_Option_float(const Option_float s);
Option(int)                 : int unwrap_Option_int(const Option_int s);
Option(string)              : string unwrap_Option_string(const Option_string s);
Option(u64)                 : u64 unwrap_Option_u64(const Option_u64 s);
Result(float, ParseError)   : float unwrap_Result_float__ParseError(const Result_float__ParseError s);
Result(int, ParseError)     : int unwrap_Result_int__ParseError(const Result_int__ParseError s);
Result(string, SystemError) : string unwrap_Result_string__SystemError(const Result_string__SystemError s);
```

## type_name

```C
type_name(e)
```

Returns the name of the type of `e` as a string constant.

Members:

```C
Line2                       : "Line2";
Option(double)              : "Option(double)";
Option(float)               : "Option(float)";
Option(int)                 : "Option(int)";
Option(string)              : "Option(string)";
Option(u64)                 : "Option(u64)";
Rect2                       : "Rect2";
Result(int, ParseError)     : "Result(int, ParseError)";
Result(string, SystemError) : "Result(string, SystemError)";
Vec2                        : "Vec2";
Vec3                        : "Vec3";
double                      : "double";
float                       : "float";
int                         : "int";
string                      : "string";
u64                         : "u64";
unsigned int                : "uint";
```

## equal_array

```C
equal_array(array1, len1, array2, len2)
```

Returns true iff len1 == len2 and for every index,
`equal(array1[i], array2[i])` is true.

Members:

```C
char   : bool equal_array_char(char* a, size_t alen, char* b, size_t blen);
double : bool equal_array_double(double* a, size_t alen, double* b, size_t blen);
float  : bool equal_array_float(float* a, size_t alen, float* b, size_t blen);
int    : bool equal_array_int(int* a, size_t alen, int* b, size_t blen);
string : bool equal_array_string(string* a, size_t alen, string* b, size_t blen);
u64    : bool equal_array_u64(u64* a, size_t alen, u64* b, size_t blen);
uint   : bool equal_array_uint(uint* a, size_t alen, uint* b, size_t blen);
```

# Macros

## DBG

```C
DBG(expr)
```

"DeBuG": print the expression `expr` and the value it evaluated
to, for debugging purposes (calls `print_debug` on the value).

## DBGA

```C
DBGA(expr, len)
```

`DBG` `A`rray: print the expression `expr` and the array value
it evaluated to, for debugging purposes (calls
`print_debug_array`). `len` must give the length of the array.

<hr>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
