<!-- THIS FILE WAS AUTO-GENERATED by gendoc. DO NOT EDIT! -->

This is the main header file of the cj50 library collection.

It includes the various other files (see the [documentation
index](index.md)), and additionally provides the utilities
described below. Besides additional functions and macros, it
defines a number of generic functions that dispatch to functions
from various other files.

# Type aliases

## ParseError {#zero.one_ParseError}

```C
typedef uint16_t ParseError
```

Values of this type (a number) describe the reason why a string
does not contain text that properly represents a value that the
used parse function should return.

Currently, numbers in the range 1..255 represent errors defined by
the operating system (errno), numbers in the range 500..29999 are
specific to cj50.h. But do *not* rely on any details of this type,
they may change, values of this type should just be passed to one
of the functions that accept it (`string_from_ParseError` and
`print_ParseError`).

# Normal functions

## fget_CStr {#one_fget_CStr}

```C
Option(CStr) fget_CStr(FILE *inp, cstr filename)
```

Read a CStr from `inp`, terminated by a newline (the newline is
not included in the returned string). Returns none on end of file
(or in the case of terminal input, when ctl-d is pressed). In case
of errors, it dies with a message that shows the `filename`.

## get_CStr {#one_get_CStr}

```C
Option(CStr) get_CStr()
```

Read a CStr from stdin (standard input), terminated by a newline
(the newline is not included in the returned string). Returns none
on end of file (when ctl-d is pressed).

## get_String {#one_get_String}

```C
Option(String) get_String()
```

Read a String from standard input, terminated by a
newline. Returns none on end of file (when ctl-d is pressed).

Note: currently can't take a `'\0'` as it works via `get_CStr`.

## string_from_ParseError {#one_string_from_ParseError}

```C
CStr string_from_ParseError(const ParseError *e)
```

Convert a `ParseError` value into a `CStr` for display.

## parse_int {#one_parse_int}

```C
Result(int, ParseError) parse_int(cstr s)
```

Translate a string into an `int` if possible.

## get_int {#one_get_int}

```C
Option(int) get_int()
```

Read an integer number from standard input, terminated by a
newline. Returns none on end of file (when ctl-d is pressed).

## parse_nat {#one_parse_nat}

```C
Result(int, ParseError) parse_nat(cstr s)
```

Translate a string into an `int` in the natural number range (1 or
higher) if possible.

## get_nat {#one_get_nat}

```C
Option(int) get_nat()
```

Read a natural number from standard input, terminated by a
newline. Returns none on end of file (when ctl-d is pressed).

## parse_nat0 {#one_parse_natQzeroE}

```C
Result(int, ParseError) parse_nat0(cstr s)
```

Translate a string into an `int` in the natural number range
including 0 (0 or higher) if possible.

## get_nat0 {#one_get_natQzeroE}

```C
Option(int) get_nat0()
```

Read a natural number or zero from standard input, terminated by a
newline. Returns none on end of file (when ctl-d is pressed).

## parse_float {#one_parse_float}

```C
Result(float, ParseError) parse_float(cstr s)
```

Translate a cstr into an `float` if possible.

## get_float {#one_get_float}

```C
Option(float) get_float()
```

Read a floating point number or zero from standard input,
terminated by a newline. Returns none on end of file (when ctl-d is
pressed).

## new_chars {#one_new_chars}

```C
char* new_chars(size_t len)
```

Allocate and return a new array of `len` char values. Aborts
when there is not enough memory (never returns the NULL
pointer). The slots in the returned array are all initialized to
the '\0' char.

## new_cstrs {#one_new_cstrs}

```C
cstr* new_cstrs(size_t len)
```

Allocate and return a new array of `len` cstr values. Aborts
when there is not enough memory (never returns the NULL
pointer). The slots in the returned array are all initialized to
the NULL pointer.

## new_Option_Strings {#one_new_Option_Strings}

```C
Option(String)* new_Option_Strings(size_t len)
```

Allocate and return a new array of `len` Option(String)
values. Aborts when there is not enough memory (never returns the
NULL pointer). The slots in the returned array are all initialized
to the none value.

## new_ints {#one_new_ints}

```C
int* new_ints(size_t len)
```

Allocate and return a new array of `len` int values. Aborts when
there is not enough memory (never returns the NULL pointer). The
slots in the returned array are all initialized to the value 0.

## new_floats {#one_new_floats}

```C
float* new_floats(size_t len)
```

Allocate and return a new array of `len` float values. Aborts when
there is not enough memory (never returns the NULL pointer). The
slots in the returned array are all initialized to the value 0.

# Generic functions

## print {#two_print}

```C
print(v)
```

Prints the given value for normal text use.

Returns an `int` that when negative signifies an error (check
`errno` for the error in this case), and when positive signifies
the number of bytes written.

Also see `print_debug` and `print_debug_array`, which support more
types, but are not meant for printing output for normal humans.

Members:

```C
CStr            : int print_move_CStr(CStr s);
CStr*           : int print_CStr(const CStr *s);
String          : int print_String(const String s);
char            : int putchar(int c);
char*           : int print_move_cstr(cstr s);
const CStr*     : int print_CStr(const CStr *s);
const utf8char* : int print_utf8char(const utf8char *c);
cstr            : int print_move_cstr(cstr s);
cstr*           : int print_cstr(const cstr *s);
double          : int print_double(double x);
float           : int print_float(float x);
int             : int print_int(int n);
u64             : int print_u64(u64 n);
u8              : int print_u8(u8 n);
uint            : int print_uint(uint n);
utf8char        : int print_move_utf8char(utf8char c);
utf8char*       : int print_utf8char(const utf8char *c);
```

## println {#two_println}

```C
println(v)
```

Prints the given value for normal text use, followed by a newline
(`"\n"`) for convenience.

Members:

```C
CStr*           : int println_CStr(const CStr *v);
String          : int println_String(String v);
char            : int println_char(char v);
char*           : int println_cstr(cstr v);
const utf8char* : int println_utf8char(const utf8char *v);
cstr            : int println_cstr(cstr v);
double          : int println_double(double v);
float           : int println_float(float v);
int             : int println_int(int v);
u64             : int println_u64(u64 v);
u8              : int println_u8(u8 v);
uint            : int println_uint(uint v);
utf8char        : int println_move_utf8char(utf8char v);
utf8char*       : int println_utf8char(const utf8char *v);
```

## print_debug {#two_print_debug}

```C
print_debug(v)
```

Prints the given value in a programmer's view, for debugging
purposes.

Returns an `int` that when negative signifies an error (check
`errno` for the error in this case), and when positive signifies
the number of bytes written.

See `print` for printing as normal text, not for debugging, and
`print_debug_array` for printing arrays.

Members:

```C
CStr                        : int print_debug_move_CStr(CStr s);
CStr*                       : int print_debug_CStr(const CStr *s);
Line2                       : int print_debug_Line2(Line2 s);
Option(CStr)                : int print_debug_move_Option_CStr(const Option_CStr s);
Option(CStr)*               : int print_debug_Option_CStr(const Option_CStr *s);
Option(String)              : int print_debug_move_Option_String(const Option_String s);
Option(String)*             : int print_debug_Option_String(const Option_String *s);
Option(cstr)                : int print_debug_move_Option_cstr(const Option_cstr s);
Option(cstr)*               : int print_debug_Option_cstr(const Option_cstr *s);
Option(float)               : int print_debug_move_Option_float(const Option_float s);
Option(float)*              : int print_debug_Option_float(const Option_float *s);
Option(int)                 : int print_debug_move_Option_int(const Option_int s);
Option(int)*                : int print_debug_Option_int(const Option_int *s);
Rect2                       : int print_debug_Rect2(Rect2 s);
Result(String, SystemError) : int print_debug_move_Result_String__SystemError( const Result_String__SystemError s);
Result(int, ParseError)     : int print_debug_move_Result_int__ParseError( const Result_int__ParseError s);
Result(int, ParseError)*    : int print_debug_Result_int__ParseError( const Result_int__ParseError *s);
String                      : int print_debug_move_String(String s);
String*                     : int print_debug_String(const String *s);
SystemError                 : int print_debug_SystemError(const SystemError *v);
UnicodeError*               : int print_debug_UnicodeError(const UnicodeError *e);
Vec(CStr)                   : int print_debug_move_Vec_CStr(Vec_CStr self);
Vec(CStr)*                  : int print_debug_Vec_CStr(const Vec_CStr *self);
Vec(ucodepoint)             : int print_debug_move_Vec_ucodepoint(Vec_ucodepoint self);
Vec(ucodepoint)*            : int print_debug_Vec_ucodepoint(const Vec_ucodepoint *self);
Vec(utf8char)               : int print_debug_move_Vec_utf8char(Vec_utf8char self);
Vec(utf8char)*              : int print_debug_Vec_utf8char(const Vec_utf8char *self);
Vec2                        : int print_debug_Vec2(Vec2 a);
Vec3                        : int print_debug_Vec3(Vec3 a);
bool                        : int print_debug_bool(bool v);
char                        : int print_debug_char(const char *c);
char*                       : int print_debug_move_cstr(cstr s);
char**                      : int print_debug_cstr(const cstr *s);
cstr                        : int print_debug_move_cstr(cstr s);
cstr*                       : int print_debug_cstr(const cstr *s);
double                      : int print_double(double x);
float                       : int print_float(float x);
int                         : int print_int(int n);
u64                         : int print_u64(u64 n);
u8                          : int print_u8(u8 n);
uint                        : int print_uint(uint n);
```

## print_debug_array {#two_print_debug_array}

```C
print_debug_array(v, len)
```

Prints the given array in a programmer's view, for debugging
purposes.

Returns an `int` that when negative signifies an error (check
`errno` for the error in this case), and when positive signifies
the number of bytes written.

See `print_debug` for printing non-array values.

Members:

```C
Option(String)* : int print_debug_Option_Strings(const Option(String)* ary, size_t len);
char*           : int print_debug_chars(const char* ary, size_t len);
cstr*           : int print_debug_cstrs(const cstr* ary, size_t len);
float*          : int print_debug_floats(const float* ary, size_t len);
int*            : int print_debug_ints(const int* ary, size_t len);
```

## drop {#two_drop}

```C
drop(v)
```

Frees the resources held by the given value (including resources
held by contained values, recursively, unlike the `free` function).

Members:

```C
CFile           : void drop_CFile(CFile f);
CStr            : void drop_CStr(CStr s);
CStrError       : void drop_CStrError(UNUSED CStrError e);
Option(CStr)    : inline void drop_Option_CStr(const Option_CStr s);
Option(String)  : inline void drop_Option_String(const Option_String s);
Option(cstr)    : inline void drop_Option_cstr(const Option_cstr s);
Option(double)  : inline void drop_Option_double(const Option_double s);
Option(float)   : inline void drop_Option_float(const Option_float s);
Option(int)     : inline void drop_Option_int(const Option_int s);
ParseError      : void drop_ParseError(UNUSED ParseError e);
String          : void drop_String(String s);
SystemError     : void drop_SystemError(UNUSED SystemError e);
UnicodeError    : void drop_UnicodeError(UnicodeError e);
Vec(CStr)       : void drop_Vec_CStr(Vec_CStr self);
Vec(ucodepoint) : void drop_Vec_ucodepoint(Vec_ucodepoint self);
Vec(utf8char)   : void drop_Vec_utf8char(Vec_utf8char self);
Vec2*           : void free(void *ptr);
Vec3*           : void free(void *ptr);
VecError        : void drop_VecError(UNUSED VecError e);
char*           : void drop_cstr(__attribute__ ((unused)) cstr s);
const char*     : void drop_cstr(__attribute__ ((unused)) cstr s);
float*          : void free(void *ptr);
int*            : void free(void *ptr);
```

## resize {#two_resize}

```C
resize(v, oldlen, newlen)
```

Expects an array as the first argument, and the current length of
the array and the desired new length. Returns a new array of the
desired new length. If the new length is shorter than the old
length, the slots that are freed are `drop`ped, if the new length
is larger, then the new slots are filled in with blanks (zero
values, NULL pointers, or similar).

Members:

```C
Option(String)* : Option(String)* resize_Option_Strings(
 Option(String)* ary, size_t oldlen, size_t newlen
 );
cstr*           : cstr* resize_cstrs(cstr* ary, size_t oldlen, size_t newlen);
float*          : float* resize_floats(float* ary, size_t oldlen, size_t newlen);
int*            : int* resize_ints(int* ary, size_t oldlen, size_t newlen);
```

## drop_array {#two_drop_array}

```C
drop_array(v, len)
```

Frees the resources held by the given array,
including all the values contained in the array (including
resources held by contained values, recursively). For arrays
holding pointers, array slots containing the NULL pointer are
skipped.

Members:

```C
Option(String)* : void drop_Option_Strings(Option(String)* ary, size_t len);
cstr*           : void drop_cstrs(cstr* ary, size_t len);
```

## equal {#two_equal}

```C
equal(a, b)
```

Takes two values of the same type and returns a `bool`. Returns
`true` if `a` and `b` are structurally equivalent.

Members:

```C
CStr*                        : bool equal_CStr(const CStr *a, const CStr *b);
Option(String)*              : bool equal_Option_String(const Option_String *a, const Option_String *b);
Option(char)                 : bool equal_move_Option_char(Option_char a, Option_char b);
Option(char)*                : bool equal_Option_char(const Option_char *a, const Option_char *b);
Option(cstr)*                : bool equal_Option_cstr(const Option_cstr *a, const Option_cstr *b);
Option(float)*               : bool equal_Option_float(const Option_float *a, const Option_float *b);
Option(int)*                 : bool equal_Option_int(const Option_int *a, const Option_int *b);
Option(utf8char)             : bool equal_move_Option_utf8char(Option_utf8char a, Option_utf8char b);
Option(utf8char)*            : bool equal_Option_utf8char(const Option_utf8char *a, const Option_utf8char *b);
Result(String, SystemError)* : bool equal_Result_String__SystemError(const Result_String__SystemError *a, const Result_String__SystemError *b);
Result(int, ParseError)*     : bool equal_Result_int__ParseError(const Result_int__ParseError *a, const Result_int__ParseError *b);
String*                      : bool equal_String(const String *a, const String *b);
bool                         : bool equal_move_bool(const bool a, const bool b);
bool*                        : bool equal_bool(const bool *a, const bool *b);
char                         : bool equal_move_char(const char a, const char b);
cstr                         : bool equal_move_cstr(cstr a, cstr b);
cstr*                        : bool equal_cstr(const cstr *a, const cstr *b);
double                       : bool equal_move_double(const double a, const double b);
double*                      : bool equal_double(const double *a, const double *b);
float                        : bool equal_move_float(const float a, const float b);
float*                       : bool equal_float(const float *a, const float *b);
int                          : bool equal_move_int(const int a, const int b);
int*                         : bool equal_int(const int *a, const int *b);
utf8char                     : bool equal_move_utf8char(utf8char a, utf8char b);
utf8char*                    : bool equal_utf8char(const utf8char *a, const utf8char *b);
```

## some {#two_some}

```C
some(v)
```

Takes a value of some type `T` and returns a `some` variant of
`Option(T)` containing the value.

Members:

```C
CStr   : Option_CStr some_CStr(const CStr val);
String : Option_String some_String(const String val);
cstr   : Option_cstr some_cstr(const cstr val);
double : Option_double some_double(const double val);
float  : Option_float some_float(const float val);
int    : Option_int some_int(const int val);
u64    : Option_u64 some_u64(const u64 val);
u8     : Option_u8 some_u8(const u8 val);
```

## none {#two_none}

```C
none(T)
```

Returns the none variant of `Option(T)` for the given
T. Equivalent to `none_T()` using the type name of T, but
`none(T)` allows T to also be a `typeof` expression.

Members:

```C
CStr   : Option_CStr none_CStr();
String : Option_String none_String();
cstr   : Option_cstr none_cstr();
double : Option_double none_double();
float  : Option_float none_float();
int    : Option_int none_int();
u64    : Option_u64 none_u64();
u8     : Option_u8 none_u8();
```

## unwrap {#two_unwrap}

```C
unwrap(v)
```

Takes a wrapper for some type `T` (like `Option(T)`, or `Result(T,
E)`) and returns the contained value of type `T` if possible, or
aborts if not possible. This moves the value, i.e. the wrapper
is consumed.

Example:

```C
Option(CStr) maybe_name = get_CStr();
// maybe_name can be a `none(CStr)` or e.g. `some("Alex")`.
CStr name = unwrap(maybe_name);
// Now we're guaranteed to have a CStr in `name`, "Alex" if we
// had the second case above. But if `maybe_name` was a none
// then the program has terminated by now instead.
```

Members:

```C
Option(CStr)                : CStr unwrap_Option_CStr(const Option_CStr s);
Option(String)              : String unwrap_Option_String(const Option_String s);
Option(char)                : char unwrap_Option_char(const Option_char s);
Option(cstr)                : cstr unwrap_Option_cstr(const Option_cstr s);
Option(double)              : double unwrap_Option_double(const Option_double s);
Option(float)               : float unwrap_Option_float(const Option_float s);
Option(int)                 : int unwrap_Option_int(const Option_int s);
Option(u64)                 : u64 unwrap_Option_u64(const Option_u64 s);
Option(u8)                  : u8 unwrap_Option_u8(const Option_u8 s);
Option(utf8char)            : utf8char unwrap_Option_utf8char(const Option_utf8char s);
Result(String, SystemError) : String unwrap_Result_String__SystemError(const Result_String__SystemError s);
Result(float, ParseError)   : float unwrap_Result_float__ParseError(const Result_float__ParseError s);
Result(int, ParseError)     : int unwrap_Result_int__ParseError(const Result_int__ParseError s);
```

## deref {#two_deref}

```C
deref(v)
```

Dereferencing a wrapper type ('smart pointer') to the simpler
contained type; the result is of a reference type (not owned).

Example:

```C
CStr s = unwrap(filecontents_CStr(path));
cstr s1 = deref(&s);
```

Members:

```C
CStr* : cstr deref_CStr(const CStr *s);
```

## type_name {#two_type_name}

```C
type_name(e)
```

Returns the name of the type of `e` as a string constant (cstr).

Members:

```C
Line2                       : "Line2";
Option(String)              : "Option(String)";
Option(cstr)                : "Option(cstr)";
Option(double)              : "Option(double)";
Option(float)               : "Option(float)";
Option(int)                 : "Option(int)";
Option(u64)                 : "Option(u64)";
Option(u8)                  : "Option(u8)";
Rect2                       : "Rect2";
Result(String, SystemError) : "Result(String, SystemError)";
Result(int, ParseError)     : "Result(int, ParseError)";
String                      : "String";
Vec(CStr)                   : "Vec(CStr)";
Vec(ucodepoint)             : "Vec(ucodepoint)";
Vec(utf8char)               : "Vec(utf8char)";
Vec2                        : "Vec2";
Vec3                        : "Vec3";
cstr                        : "cstr";
double                      : "double";
float                       : "float";
int                         : "int";
u64                         : "u64";
u8                          : "u8";
unsigned int                : "uint";
```

## equal_array {#two_equal_array}

```C
equal_array(array1, len1, array2, len2)
```

Returns true iff len1 == len2 and for every index,
`equal(array1[i], array2[i])` is true.

Members:

```C
String : bool equal_array_String(String* a, size_t alen, String* b, size_t blen);
char   : bool equal_array_char(char* a, size_t alen, char* b, size_t blen);
cstr   : bool equal_array_cstr(cstr* a, size_t alen, cstr* b, size_t blen);
double : bool equal_array_double(double* a, size_t alen, double* b, size_t blen);
float  : bool equal_array_float(float* a, size_t alen, float* b, size_t blen);
int    : bool equal_array_int(int* a, size_t alen, int* b, size_t blen);
u64    : bool equal_array_u64(u64* a, size_t alen, u64* b, size_t blen);
uint   : bool equal_array_uint(uint* a, size_t alen, uint* b, size_t blen);
```

## push {#two_push}

```C
push(coll, val)
```

Push a value onto the end of a collection. For Vec and String.

Members:

```C
Vec(CStr)*       : void push_Vec_CStr(Vec_CStr *self, CStr value);
Vec(ucodepoint)* : void push_Vec_ucodepoint(Vec_ucodepoint *self, ucodepoint value);
Vec(utf8char)*   : void push_Vec_utf8char(Vec_utf8char *self, utf8char value);
```

## pop {#two_pop}

```C
pop(coll)
```

Pop a value off the end of a collection. For Vec and String.

Members:

```C
Vec(CStr)*       : Option_CStr pop_Vec_CStr(Vec_CStr *self);
Vec(ucodepoint)* : Option_ucodepoint pop_Vec_ucodepoint(Vec_ucodepoint *self);
Vec(utf8char)*   : Option_utf8char pop_Vec_utf8char(Vec_utf8char *self);
```

## append {#two_append}

```C
append(coll1, coll2)
```

Append the items from coll2 onto the end of coll1, leaving coll2
empty. For Vec and String.

Members:

```C
Vec(CStr)*       : void append_Vec_CStr(Vec_CStr *self, Vec_CStr *other);
Vec(ucodepoint)* : void append_Vec_ucodepoint(Vec_ucodepoint *self, Vec_ucodepoint *other);
Vec(utf8char)*   : void append_Vec_utf8char(Vec_utf8char *self, Vec_utf8char *other);
```

## len {#two_len}

```C
len(coll)
```

Give the length of a given collection. For Vec (and String. XXX
bytes or characters...?)

Members:

```C
String*          : size_t len_String(const String *s);
Vec(CStr)*       : size_t len_Vec_CStr(const Vec_CStr *self);
Vec(ucodepoint)* : size_t len_Vec_ucodepoint(const Vec_ucodepoint *self);
Vec(utf8char)*   : size_t len_Vec_utf8char(const Vec_utf8char *self);
```

## cstr {#two_cstr}

```C
cstr(v)
```

Give the length of a given collection. For Vec (and String. XXX
bytes or characters...?)

Members:

```C
CStr*     : cstr cstr_CStr(CStr *s);
String*   : Option(cstr) cstr_String(String *s);
utf8char* : cstr cstr_utf8char(const utf8char *c);
```

## fprintln {#two_fprintln}

```C
fprintln(out, v)
```

Like println but printing to `out`.

(Currently only defined for types for which `unwrap` is defined,
to be used for error messaging. Todo: define `println` in terms of
`fprintln` and thus share implementations.)

Members:

```C
CStrError*     : int fprintln_CStrError(FILE *out, const CStrError *e);
DecodingError* : int fprintln_DecodingError(FILE* out, const DecodingError* e);
ParseError*    : int fprintln_ParseError(FILE* out, const ParseError *e);
SystemError*   : int fprintln_SystemError(FILE* out, const SystemError *e);
UnicodeError*  : int fprintln_UnicodeError(FILE* out, const UnicodeError* e);
VecError*      : int fprintln_VecError(FILE *out, const VecError *e);
```

## get_utf8char {#two_get_utfQeightEchar}

```C
get_utf8char(s, idx)
```

Get a `utf8char` from a collection.

Members:

```C
String* : Option(utf8char) get_utf8char_String(const String *s, size_t idx);
```

# Macros

## DBG {#three_DBG}

```C
DBG(expr)
```

"DeBuG": print the expression `expr` and the value it evaluated
to, for debugging purposes (calls `print_debug` on the value).

## DBGA {#three_DBGA}

```C
DBGA(expr, len)
```

`DBG` `A`rray: print the expression `expr` and the array value
it evaluated to, for debugging purposes (calls
`print_debug_array`). `len` must give the length of the array.

<hr>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
