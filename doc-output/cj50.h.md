<!-- THIS FILE WAS AUTO-GENERATED by gendoc. DO NOT EDIT! -->

This is the main header file of the cj50 library collection.

It includes the various other files (see the [documentation
index](index.md)), and additionally provides the utilities
described below. Besides additional functions and macros, it
defines a number of generic functions that dispatch to functions
from various other files.

# Type aliases

## ParseError

```C
typedef uint16_t ParseError
```

Values of this type (a number) describe the reason why a string
does not contain text that properly represents a value that the
used parse function should return.

Currently, numbers in the range 1..255 represent errors defined by
the operating system (errno), numbers in the range 500..29999 are
specific to cj50.h. But do *not* rely on any details of this type,
they may change, values of this type should just be passed to one
of the functions that accept it (`string_from_ParseError` and
`print_ParseError`).

## uint

```C
typedef unsigned int uint
```

An integer number type that cannot represent negative numbers, but
instead has a little more room in the positive number range than
`int` (0 .. `UINT_MAX`).

CAUTION: arithmetic with numbers of this type does wrap around if
the result of the arithmetic operation is larger than the largest
number that can be represented with this type, or smaller than
0. This is unlike arithmetic with `int`, where such overflows are
an error and (with the compiler options that we use) abort the
program. So it is best to avoid `uint` and always use `int`
instead, except when using functions from libraries or the
operating system that use this type.

# Normal functions

## get_string

```C
Option(string) get_string()
```

Read a string from standard input, terminated by a
newline. Returns none on end of file (when ctl-d is pressed).

## string_from_ParseError

```C
const char* string_from_ParseError(ParseError e)
```

Convert a `ParseError` value into a `string` for display. The
returned string has static life time (do not try to free or drop it).

## parse_int

```C
Result(int, ParseError) parse_int(string s)
```

Translate a string into an `int` if possible.

## get_int

```C
Option(int) get_int()
```

Read an integer number from standard input, terminated by a
newline. Returns none on end of file (when ctl-d is pressed).

## get_nat

```C
Option(int) get_nat()
```

Read a natural number from standard input, terminated by a
newline. Returns none on end of file (when ctl-d is pressed).

## get_nat0

```C
Option(int) get_nat0()
```

Read a natural number or zero from standard input, terminated by a
newline. Returns none on end of file (when ctl-d is pressed).

## get_float

```C
Option(float) get_float()
```

Read a floating point number or zero from standard input,
terminated by a newline. Returns none on end of file (when ctl-d is
pressed).

## new_chars

```C
char* new_chars(size_t len)
```

Allocate and return a new array of `len` char values. Aborts
when there is not enough memory (never returns the NULL
pointer). The slots in the returned array are all initialized to
the '\0' char. This is the same as `new_string`.

## new_string

```C
string new_string(size_t len)
```

Allocate and return a new string of capacity `len`. Aborts when
there is not enough memory (never returns the NULL pointer). The
string is set to the empty string. This is the same as
`new_chars`.

## new_strings

```C
string* new_strings(size_t len)
```

Allocate and return a new array of `len` string values. Aborts
when there is not enough memory (never returns the NULL
pointer). The slots in the returned array are all initialized to
the NULL pointer.

## new_ints

```C
int* new_ints(size_t len)
```

Allocate and return a new array of `len` int values. Aborts when
there is not enough memory (never returns the NULL pointer). The
slots in the returned array are all initialized to the value 0.

## new_floats

```C
float* new_floats(size_t len)
```

Allocate and return a new array of `len` float values. Aborts when
there is not enough memory (never returns the NULL pointer). The
slots in the returned array are all initialized to the value 0.

# Generic functions

## print

```C
print(v)
```

Prints the given value for normal text use.

Returns an `int` that when negative signifies an error (check
`errno` for the error in this case), and when positive signifies
the number of bytes written.

Also see `print_debug` and `print_debug_array`, which support more
types, but are not meant for printing output for normal humans.

Members:

```C
char  : int putchar(int c);
char* : int print_string(const_string str);
float : int print_float(float x);
int   : int print_int(int n);
uint  : int print_uint(uint n);
```

## print_debug

```C
print_debug(v)
```

Prints the given value in a programmer's view, for debugging
purposes.

Returns an `int` that when negative signifies an error (check
`errno` for the error in this case), and when positive signifies
the number of bytes written.

See `print` for printing as normal text, not for debugging, and
`print_debug_array` for printing arrays.

Members:

```C
Line2                    : int print_debug_Line2(Line2 s);
Option(float)            : int print_debug_move_Option_float(const Option_float s);
Option(float)*           : int print_debug_Option_float(const Option_float *s);
Option(int)              : int print_debug_move_Option_int(const Option_int s);
Option(int)*             : int print_debug_Option_int(const Option_int *s);
Option(string)           : int print_debug_move_Option_string(const Option_string s);
Option(string)*          : int print_debug_Option_string(const Option_string *s);
Rect2                    : int print_debug_Rect2(Rect2 s);
Result(int, ParseError)  : int print_debug_move_Result_int__ParseError( const Result_int__ParseError s);
Result(int, ParseError)* : int print_debug_Result_int__ParseError( const Result_int__ParseError *s);
Vec2                     : int print_debug_Vec2(Vec2 a);
Vec3                     : int print_debug_Vec3(Vec3 a);
char                     : int print_debug_char(char c);
char*                    : int print_debug_string(const_string str);
float                    : int print_float(float x);
int                      : int print_int(int n);
uint                     : int print_uint(uint n);
```

## print_debug_array

```C
print_debug_array(v, len)
```

Prints the given array in a programmer's view, for debugging
purposes.

Returns an `int` that when negative signifies an error (check
`errno` for the error in this case), and when positive signifies
the number of bytes written.

See `print_debug` for printing non-array values.

Members:

```C
char*   : int print_debug_chars(const char* ary, size_t len);
float*  : int print_debug_floats(const float* ary, size_t len);
int*    : int print_debug_ints(const int* ary, size_t len);
string* : int print_debug_strings(const string* ary, size_t len);
```

## resize

```C
resize(v, oldlen, newlen)
```

Expects an array as the first argument, and the current length of
the array and the desired new length. Returns a new array of the
desired new length. If the new length is shorter than the old
length, the slots that are freed are `drop`ped, if the new length
is larger, then the new slots are filled in with blanks (zero
values, NULL pointers, or similar).

Members:

```C
float*  : float* resize_floats(float* ary, size_t oldlen, size_t newlen);
int*    : int* resize_ints(int* ary, size_t oldlen, size_t newlen);
string* : string* resize_strings(string* ary, size_t oldlen, size_t newlen);
```

## drop

```C
drop(v)
```

Frees the resources held by the given value (including resources
held by contained values, recursively, unlike the `free` function).

Members:

```C
Option(float)  : inline void drop_Option_float(const Option_float s);
Option(int)    : inline void drop_Option_int(const Option_int s);
Option(string) : inline void drop_Option_string(const Option_string s);
Vec2*          : void free(void *ptr);
Vec3*          : void free(void *ptr);
char*          : void drop_string(string s);
float*         : void free(void *ptr);
int*           : void free(void *ptr);
```

## drop_array

```C
drop_array(v, len)
```

Frees the resources held by the given array,
including all the values contained in the array (including
resources held by contained values, recursively). For arrays
holding pointers, array slots containing the NULL pointer are
skipped.

Members:

```C
string* : void free_strings(string* ary, size_t len);
```

## equal

```C
equal(a, b)
```

Takes two values of the same type and returns a `bool`. Returns
`true` if `a` and `b` are structurally equivalent.

Members:

```C
Option(float)*           : bool equal_Option_float(const Option_float *a, const Option_float *b);
Option(int)*             : bool equal_Option_int(const Option_int *a, const Option_int *b);
Option(string)*          : bool equal_Option_string(const Option_string *a, const Option_string *b);
Result(int, ParseError)* : bool equal_Result_int__ParseError(const Result_int__ParseError *a, const Result_int__ParseError *b);
```

## some

```C
some(v)
```

Takes a value of some type `T` and returns a `some` variant of
`Option(T)` containing the value.

Members:

```C
float  : Option_float some_float(const float val);
int    : Option_int some_int(const int val);
string : Option_string some_string(const string val);
```

## none

```C
none(T)
```

Returns the none variant of `Option(T)` for the given
T. Equivalent to `none_T()` using the type name of T, but
`none(T)` allows T to also be a `typeof` expression.

Members:

```C
float  : Option_float none_float();
int    : Option_int none_int();
string : Option_string none_string();
```

## unwrap

```C
unwrap(v)
```

Takes a wrapper for some type `T` (like `Option(T)`, or `Result(T,
E)`) and returns the contained value of type `T` if possible, or
aborts if not possible.

Example:

```C
Option(string) maybe_name = get_string();
// maybe_name can be a `none(string)` or e.g. `some("Alex")`.
string name = unwrap(maybe_name);
// Now we're guaranteed to have a string in `name`, "Alex" if we
// had the second case above. But if `maybe_name` was a none
// then the program has terminated by now instead.
```

Members:

```C
Option(float)           : float unwrap_Option_float(const Option_float s);
Option(int)             : int unwrap_Option_int(const Option_int s);
Option(string)          : string unwrap_Option_string(const Option_string s);
Result(int, ParseError) : int unwrap_Result_int__ParseError(const Result_int__ParseError s);
```

## type_name

```C
type_name(e)
```

Returns the name of the type of `e` as a string constant.

Members:

```C
Line2                   : "Line2";
Option(float)           : "Option(float)";
Option(int)             : "Option(int)";
Option(string)          : "Option(string)";
Rect2                   : "Rect2";
Result(int, ParseError) : "Result(int, ParseError)";
Vec2                    : "Vec2";
Vec3                    : "Vec3";
double                  : "double";
float                   : "float";
int                     : "int";
string                  : "string";
unsigned int            : "uint";
```

## equal_array

```C
equal_array(array1, len1, array2, len2)
```

Returns true iff len1 == len2 and for every index,
`equal(array1[i], array2[i])` is true.

Members:

```C
char   : bool equal_array_char(char* a, size_t alen, char* b, size_t blen);
float  : bool equal_array_float(float* a, size_t alen, float* b, size_t blen);
int    : bool equal_array_int(int* a, size_t alen, int* b, size_t blen);
string : bool equal_array_string(string* a, size_t alen, string* b, size_t blen);
```

# Macros

## D

```C
D(expr)
```

`D`ebug: print the expression `expr` and the value it evaluated
to, for debugging purposes (calls `print_debug` on the value).

## DA

```C
DA(expr, len)
```

`D`ebug `A`rray: print the expression `expr` and the array value
it evaluated to, for debugging purposes (calls
`print_debug_array`). `len` must give the length of the array.

<hr>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
