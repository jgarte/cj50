<!-- THIS FILE WAS AUTO-GENERATED by gendoc. DO NOT EDIT! -->

This is the main header file of the cj50 library collection.

It includes the various other files (see the [documentation
index](index.md)), and additionally provides the utilities
described below. Besides additional functions and macros, it
defines a number of generic functions that dispatch to functions
from various other files.

# Type aliases

## ParseError {#zero.one_ParseError}

```C
typedef uint16_t ParseError
```

Values of this type (a number) describe the reason why a string
does not contain text that properly represents a value that the
used parse function should return.

Currently, numbers in the range 1..255 represent errors defined by
the operating system (errno), numbers in the range 500..29999 are
specific to cj50.h. But do *not* rely on any details of this type,
they may change, values of this type should just be passed to one
of the functions that accept it (`string_from_ParseError` and
`print_ParseError`).

# Normal functions

## get_CStr {#one_get_CStr}

```C
Option(CStr) get_CStr()
```

Read a CStr from stdin (standard input), terminated by a newline
(the newline is not included in the returned string). Returns none
on end of file (when ctl-d is pressed).

## get_String {#one_get_String}

```C
Option(String) get_String()
```

Read a String from standard input, terminated by a
newline. Returns none on end of file (when ctl-d is pressed).

Note: currently can't take a `'\0'` as it works via `get_CStr`.

## string_from_ParseError {#one_string_from_ParseError}

```C
CStr string_from_ParseError(const ParseError *e)
```

Convert a `ParseError` value into a `CStr` for display.

## parse_int {#one_parse_int}

```C
Result(int, ParseError) parse_int(cstr s)
```

Translate a string into an `int` if possible.

## get_int {#one_get_int}

```C
Option(int) get_int()
```

Read an integer number from standard input, terminated by a
newline. Returns none on end of file (when ctl-d is pressed).

## parse_nat {#one_parse_nat}

```C
Result(int, ParseError) parse_nat(cstr s)
```

Translate a string into an `int` in the natural number range (1 or
higher) if possible.

## get_nat {#one_get_nat}

```C
Option(int) get_nat()
```

Read a natural number from standard input, terminated by a
newline. Returns none on end of file (when ctl-d is pressed).

## parse_nat0 {#one_parse_natQzeroE}

```C
Result(int, ParseError) parse_nat0(cstr s)
```

Translate a string into an `int` in the natural number range
including 0 (0 or higher) if possible.

## get_nat0 {#one_get_natQzeroE}

```C
Option(int) get_nat0()
```

Read a natural number or zero from standard input, terminated by a
newline. Returns none on end of file (when ctl-d is pressed).

## parse_float {#one_parse_float}

```C
Result(float, ParseError) parse_float(cstr s)
```

Translate a cstr into an `float` if possible.

## get_float {#one_get_float}

```C
Option(float) get_float()
```

Read a floating point number or zero from standard input,
terminated by a newline. Returns none on end of file (when ctl-d is
pressed).

## new_chars {#one_new_chars}

```C
char* new_chars(size_t len)
```

Allocate and return a new array of `len` char values. Aborts
when there is not enough memory (never returns the NULL
pointer). The slots in the returned array are all initialized to
the '\0' char.

## new_cstrs {#one_new_cstrs}

```C
cstr* new_cstrs(size_t len)
```

Allocate and return a new array of `len` cstr values. Aborts
when there is not enough memory (never returns the NULL
pointer). The slots in the returned array are all initialized to
the NULL pointer.

## new_Option_Strings {#one_new_Option_Strings}

```C
Option(String)* new_Option_Strings(size_t len)
```

Allocate and return a new array of `len` Option(String)
values. Aborts when there is not enough memory (never returns the
NULL pointer). The slots in the returned array are all initialized
to the none value.

## new_ints {#one_new_ints}

```C
int* new_ints(size_t len)
```

Allocate and return a new array of `len` int values. Aborts when
there is not enough memory (never returns the NULL pointer). The
slots in the returned array are all initialized to the value 0.

## new_floats {#one_new_floats}

```C
float* new_floats(size_t len)
```

Allocate and return a new array of `len` float values. Aborts when
there is not enough memory (never returns the NULL pointer). The
slots in the returned array are all initialized to the value 0.

## env_is_true {#one_env_is_true}

```C
bool env_is_true(cstr varname)
```

Return true if the environment variable with the given name is set
to a string that is not "0"

# Generic functions

## print {#two_print}

```C
print(v)
```

Prints the given value for normal text use.

Returns an `int` that when negative signifies an error (check
`errno` for the error in this case), and when positive signifies
the number of bytes written.

Also see `print_debug` and `print_debug_array`, which support more
types, but are not meant for printing output for normal humans.

Members:

```C
CStr              : int print_move_CStr(CStr s);
CStr*             : int print_CStr(const CStr *s);
String            : int print_move_String(String s);
String*           : int print_String(const String *s);
char              : int putchar(int c);
char*             : int print_move_cstr(cstr s);
const CStr*       : int print_CStr(const CStr *s);
const String*     : int print_String(const String *s);
const cstr*       : int print_cstr(const cstr *s);
const double*     : int print_double(const double *x);
const float*      : int print_float(const float *x);
const int*        : int print_int(const int *n);
const u32*        : int print_u32(const u32 *n);
const u64*        : int print_u64(const u64 *n);
const u8*         : int print_u8(const u8 *n);
const ucodepoint* : int print_ucodepoint(const ucodepoint *a);
const utf8char*   : int print_utf8char(const utf8char *c);
cstr              : int print_move_cstr(cstr s);
cstr*             : int print_cstr(const cstr *s);
double            : int print_move_double(double x);
double*           : int print_double(const double *x);
float             : int print_move_float(float x);
float*            : int print_float(const float *x);
int               : int print_move_int(int n);
int*              : int print_int(const int *n);
u32               : int print_move_u32(u32 n);
u32*              : int print_u32(const u32 *n);
u64               : int print_move_u64(u64 n);
u64*              : int print_u64(const u64 *n);
u8                : int print_move_u8(u8 n);
u8*               : int print_u8(const u8 *n);
ucodepoint        : int print_move_ucodepoint(ucodepoint a);
ucodepoint*       : int print_ucodepoint(const ucodepoint *a);
utf8char          : int print_move_utf8char(utf8char c);
utf8char*         : int print_utf8char(const utf8char *c);
```

## println {#two_println}

```C
println(v)
```

Prints the given value for normal text use, followed by a newline
(`"\n"`) for convenience.

Members:

```C
CStr              : int println_move_CStr(CStr v);
CStr*             : int println_CStr(const CStr *v);
String            : int println_move_String(String v);
String*           : int println_String(const String *v);
char              : int println_move_char(char v);
char*             : int println_move_cstr(cstr v);
const CStr*       : int println_CStr(const CStr *v);
const String*     : int println_String(const String *v);
const cstr*       : int println_cstr(const cstr *v);
const double*     : int println_double(const double *v);
const float*      : int println_float(const float *v);
const u32*        : int println_u32(const u32 *v);
const u64*        : int println_u64(const u64 *v);
const u8*         : int println_u8(const u8 *v);
const ucodepoint* : int println_ucodepoint(const ucodepoint *v);
const utf8char*   : int println_utf8char(const utf8char *v);
cstr              : int println_move_cstr(cstr v);
cstr*             : int println_cstr(const cstr *v);
double            : int println_move_double(double v);
double*           : int println_double(const double *v);
float             : int println_move_float(float v);
float*            : int println_float(const float *v);
int               : int println_int(const int *v);
u32               : int println_move_u32(u32 v);
u32*              : int println_u32(const u32 *v);
u64               : int println_move_u64(u64 v);
u64*              : int println_u64(const u64 *v);
u8                : int println_move_u8(u8 v);
u8*               : int println_u8(const u8 *v);
ucodepoint        : int println_move_ucodepoint(ucodepoint v);
ucodepoint*       : int println_ucodepoint(const ucodepoint *v);
utf8char          : int println_move_utf8char(utf8char v);
utf8char*         : int println_utf8char(const utf8char *v);
```

## print_debug {#two_print_debug}

```C
print_debug(v)
```

Prints the given value in a programmer's view, for debugging
purposes.

Returns an `int` that when negative signifies an error (check
`errno` for the error in this case), and when positive signifies
the number of bytes written.

See `print` for printing as normal text, not for debugging, and
`print_debug_array` for printing arrays.

Members:

```C
CStr                           : int print_debug_move_CStr(CStr s);
CStr*                          : int print_debug_CStr(const CStr *s);
Color                          : int print_debug_move_Color(Color v);
Color*                         : int print_debug_Color(const Color *v);
Line2                          : int print_debug_move_Line2(Line2 s);
Line2*                         : int print_debug_Line2(const Line2 *s);
Option(CStr)                   : int print_debug_move_Option_CStr(const Option_CStr s);
Option(CStr)*                  : int print_debug_Option_CStr(const Option_CStr *s);
Option(String)                 : int print_debug_move_Option_String(const Option_String s);
Option(String)*                : int print_debug_Option_String(const Option_String *s);
Option(cstr)                   : int print_debug_move_Option_cstr(const Option_cstr s);
Option(cstr)*                  : int print_debug_Option_cstr(const Option_cstr *s);
Option(float)                  : int print_debug_move_Option_float(const Option_float s);
Option(float)*                 : int print_debug_Option_float(const Option_float *s);
Option(int)                    : int print_debug_move_Option_int(const Option_int s);
Option(int)*                   : int print_debug_Option_int(const Option_int *s);
Rect2                          : int print_debug_move_Rect2(Rect2 s);
Rect2*                         : int print_debug_Rect2(const Rect2 *s);
Result(String, SystemError)    : int print_debug_move_Result_String__SystemError( const Result_String__SystemError s);
Result(int, ParseError)        : int print_debug_move_Result_int__ParseError( const Result_int__ParseError s);
Result(int, ParseError)*       : int print_debug_Result_int__ParseError( const Result_int__ParseError *s);
String                         : int print_debug_move_String(String s);
String*                        : int print_debug_String(const String *s);
SystemError                    : int print_debug_SystemError(const SystemError *v);
UnicodeError*                  : int print_debug_UnicodeError(const UnicodeError *e);
Vec(CStr)                      : int print_debug_move_Vec_CStr(Vec_CStr self);
Vec(CStr)*                     : int print_debug_Vec_CStr(const Vec_CStr *self);
Vec(Vec2)                      : int print_debug_move_Vec_Vec2(Vec_Vec2 self);
Vec(Vec2)*                     : int print_debug_Vec_Vec2(const Vec_Vec2 *self);
Vec(char)                      : int print_debug_move_Vec_char(Vec_char self);
Vec(char)*                     : int print_debug_Vec_char(const Vec_char *self);
Vec(cstr)                      : int print_debug_move_Vec_cstr(Vec_cstr self);
Vec(cstr)*                     : int print_debug_Vec_cstr(const Vec_cstr *self);
Vec(double)                    : int print_debug_move_Vec_double(Vec_double self);
Vec(double)*                   : int print_debug_Vec_double(const Vec_double *self);
Vec(float)                     : int print_debug_move_Vec_float(Vec_float self);
Vec(float)*                    : int print_debug_Vec_float(const Vec_float *self);
Vec(int)                       : int print_debug_move_Vec_int(Vec_int self);
Vec(int)*                      : int print_debug_Vec_int(const Vec_int *self);
Vec(ucodepoint)                : int print_debug_move_Vec_ucodepoint(Vec_ucodepoint self);
Vec(ucodepoint)*               : int print_debug_Vec_ucodepoint(const Vec_ucodepoint *self);
Vec(utf8char)                  : int print_debug_move_Vec_utf8char(Vec_utf8char self);
Vec(utf8char)*                 : int print_debug_Vec_utf8char(const Vec_utf8char *self);
Vec2                           : int print_debug_move_Vec2(Vec2 a);
Vec2*                          : int print_debug_Vec2(const Vec2 *a);
Vec3                           : int print_debug_move_Vec3(Vec3 a);
Vec3*                          : int print_debug_Vec3(const Vec3 *a);
bool                           : int print_debug_bool(const bool *v);
char                           : int print_debug_char(const char *c);
char*                          : int print_debug_move_cstr(cstr s);
char**                         : int print_debug_cstr(const cstr *s);
const CStr*                    : int print_debug_CStr(const CStr *s);
const Color*                   : int print_debug_Color(const Color *v);
const Option(CStr)*            : int print_debug_Option_CStr(const Option_CStr *s);
const Option(String)*          : int print_debug_Option_String(const Option_String *s);
const Option(cstr)*            : int print_debug_Option_cstr(const Option_cstr *s);
const Option(float)*           : int print_debug_Option_float(const Option_float *s);
const Option(int)*             : int print_debug_Option_int(const Option_int *s);
const Result(int, ParseError)* : int print_debug_Result_int__ParseError( const Result_int__ParseError *s);
const String*                  : int print_debug_String(const String *s);
const UnicodeError*            : int print_debug_UnicodeError(const UnicodeError *e);
const Vec(CStr)*               : int print_debug_Vec_CStr(const Vec_CStr *self);
const Vec(Vec2)*               : int print_debug_Vec_Vec2(const Vec_Vec2 *self);
const Vec(char)*               : int print_debug_Vec_char(const Vec_char *self);
const Vec(cstr)*               : int print_debug_Vec_cstr(const Vec_cstr *self);
const Vec(double)*             : int print_debug_Vec_double(const Vec_double *self);
const Vec(float)*              : int print_debug_Vec_float(const Vec_float *self);
const Vec(int)*                : int print_debug_Vec_int(const Vec_int *self);
const Vec(ucodepoint)*         : int print_debug_Vec_ucodepoint(const Vec_ucodepoint *self);
const Vec(utf8char)*           : int print_debug_Vec_utf8char(const Vec_utf8char *self);
const cstr*                    : int print_debug_cstr(const cstr *s);
const double*                  : int print_double(const double *x);
const float*                   : int print_float(const float *x);
const int*                     : int print_int(const int *n);
const mutslice(CStr)*          : int print_debug_mutslice_CStr(const mutslice_CStr *self);
const mutslice(Vec2)*          : int print_debug_mutslice_Vec2(const mutslice_Vec2 *self);
const mutslice(char)*          : int print_debug_mutslice_char(const mutslice_char *self);
const mutslice(cstr)*          : int print_debug_mutslice_cstr(const mutslice_cstr *self);
const mutslice(int)*           : int print_debug_mutslice_int(const mutslice_int *self);
const mutslice(ucodepoint)*    : int print_debug_mutslice_ucodepoint(const mutslice_ucodepoint *self);
const mutslice(utf8char)*      : int print_debug_mutslice_utf8char(const mutslice_utf8char *self);
const slice(CStr)*             : int print_debug_slice_CStr(const slice_CStr *self);
const slice(Vec2)*             : int print_debug_slice_Vec2(const slice_Vec2 *self);
const slice(char)*             : int print_debug_slice_char(const slice_char *self);
const slice(cstr)*             : int print_debug_slice_cstr(const slice_cstr *self);
const slice(int)*              : int print_debug_slice_int(const slice_int *self);
const slice(ucodepoint)*       : int print_debug_slice_ucodepoint(const slice_ucodepoint *self);
const slice(utf8char)*         : int print_debug_slice_utf8char(const slice_utf8char *self);
const u32*                     : int print_u32(const u32 *n);
const u64*                     : int print_u64(const u64 *n);
const u8*                      : int print_u8(const u8 *n);
const ucodepoint*              : int print_debug_ucodepoint(const ucodepoint *a);
const utf8char*                : int print_debug_utf8char(const utf8char *c);
cstr                           : int print_debug_move_cstr(cstr s);
cstr*                          : int print_debug_cstr(const cstr *s);
double                         : int print_move_double(double x);
double*                        : int print_double(const double *x);
float                          : int print_move_float(float x);
float*                         : int print_float(const float *x);
int                            : int print_move_int(int n);
int*                           : int print_int(const int *n);
mutslice(CStr)                 : int print_debug_move_mutslice_CStr(mutslice_CStr self);
mutslice(CStr)*                : int print_debug_mutslice_CStr(const mutslice_CStr *self);
mutslice(Vec2)                 : int print_debug_move_mutslice_Vec2(mutslice_Vec2 self);
mutslice(Vec2)*                : int print_debug_mutslice_Vec2(const mutslice_Vec2 *self);
mutslice(char)                 : int print_debug_move_mutslice_char(mutslice_char self);
mutslice(char)*                : int print_debug_mutslice_char(const mutslice_char *self);
mutslice(cstr)                 : int print_debug_move_mutslice_cstr(mutslice_cstr self);
mutslice(cstr)*                : int print_debug_mutslice_cstr(const mutslice_cstr *self);
mutslice(int)                  : int print_debug_move_mutslice_int(mutslice_int self);
mutslice(int)*                 : int print_debug_mutslice_int(const mutslice_int *self);
mutslice(ucodepoint)           : int print_debug_move_mutslice_ucodepoint(mutslice_ucodepoint self);
mutslice(ucodepoint)*          : int print_debug_mutslice_ucodepoint(const mutslice_ucodepoint *self);
mutslice(utf8char)             : int print_debug_move_mutslice_utf8char(mutslice_utf8char self);
mutslice(utf8char)*            : int print_debug_mutslice_utf8char(const mutslice_utf8char *self);
slice(CStr)                    : int print_debug_move_slice_CStr(slice_CStr self);
slice(CStr)*                   : int print_debug_slice_CStr(const slice_CStr *self);
slice(Vec2)                    : int print_debug_move_slice_Vec2(slice_Vec2 self);
slice(Vec2)*                   : int print_debug_slice_Vec2(const slice_Vec2 *self);
slice(char)                    : int print_debug_move_slice_char(slice_char self);
slice(char)*                   : int print_debug_slice_char(const slice_char *self);
slice(cstr)                    : int print_debug_move_slice_cstr(slice_cstr self);
slice(cstr)*                   : int print_debug_slice_cstr(const slice_cstr *self);
slice(int)                     : int print_debug_move_slice_int(slice_int self);
slice(int)*                    : int print_debug_slice_int(const slice_int *self);
slice(ucodepoint)              : int print_debug_move_slice_ucodepoint(slice_ucodepoint self);
slice(ucodepoint)*             : int print_debug_slice_ucodepoint(const slice_ucodepoint *self);
slice(utf8char)                : int print_debug_move_slice_utf8char(slice_utf8char self);
slice(utf8char)*               : int print_debug_slice_utf8char(const slice_utf8char *self);
u32                            : int print_move_u32(u32 n);
u32*                           : int print_u32(const u32 *n);
u64                            : int print_move_u64(u64 n);
u64*                           : int print_u64(const u64 *n);
u8                             : int print_move_u8(u8 n);
u8*                            : int print_u8(const u8 *n);
ucodepoint                     : int print_debug_move_ucodepoint(ucodepoint a);
ucodepoint*                    : int print_debug_ucodepoint(const ucodepoint *a);
utf8char                       : int print_debug_move_utf8char(utf8char c);
utf8char*                      : int print_debug_utf8char(const utf8char *c);
```

## print_debug_array {#two_print_debug_array}

```C
print_debug_array(v, len)
```

Prints the given array in a programmer's view, for debugging
purposes.

Returns an `int` that when negative signifies an error (check
`errno` for the error in this case), and when positive signifies
the number of bytes written.

See `print_debug` for printing non-array values.

Members:

```C
Option(String)* : int print_debug_Option_Strings(const Option(String)* ary, size_t len);
char*           : int print_debug_chars(const char* ary, size_t len);
cstr*           : int print_debug_cstrs(const cstr* ary, size_t len);
float*          : int print_debug_floats(const float* ary, size_t len);
int*            : int print_debug_ints(const int* ary, size_t len);
```

## drop {#two_drop}

```C
drop(v)
```

Frees the resources held by the given value (including resources
held by contained values, recursively, unlike the `free` function).

Members:

```C
CFile                : void drop_CFile(CFile f);
CStr                 : void drop_CStr(CStr s);
CStrError            : void drop_CStrError(UNUSED CStrError e);
Option(CStr)         : inline void drop_Option_CStr(const Option_CStr s);
Option(String)       : inline void drop_Option_String(const Option_String s);
Option(cstr)         : inline void drop_Option_cstr(const Option_cstr s);
Option(double)       : inline void drop_Option_double(const Option_double s);
Option(float)        : inline void drop_Option_float(const Option_float s);
Option(int)          : inline void drop_Option_int(const Option_int s);
ParseError           : void drop_ParseError(UNUSED ParseError e);
String               : void drop_String(String s);
SystemError          : void drop_SystemError(UNUSED SystemError e);
UnicodeError         : void drop_UnicodeError(UnicodeError e);
Vec(CStr)            : void drop_Vec_CStr(Vec_CStr self);
Vec(Vec2)            : void drop_Vec_Vec2(Vec_Vec2 self);
Vec(char)            : void drop_Vec_char(Vec_char self);
Vec(cstr)            : void drop_Vec_cstr(Vec_cstr self);
Vec(double)          : void drop_Vec_double(Vec_double self);
Vec(float)           : void drop_Vec_float(Vec_float self);
Vec(int)             : void drop_Vec_int(Vec_int self);
Vec(ucodepoint)      : void drop_Vec_ucodepoint(Vec_ucodepoint self);
Vec(utf8char)        : void drop_Vec_utf8char(Vec_utf8char self);
Vec2*                : void free(void *ptr);
Vec3*                : void free(void *ptr);
VecError             : void drop_VecError(UNUSED VecError e);
char*                : void drop_cstr(__attribute__ ((unused)) cstr s);
const char*          : void drop_cstr(__attribute__ ((unused)) cstr s);
float*               : void free(void *ptr);
int*                 : void free(void *ptr);
mutslice(CStr)       : void drop_mutslice_CStr(__attribute__ ((unused)) mutslice_CStr self);
mutslice(cstr)       : void drop_mutslice_cstr(__attribute__ ((unused)) mutslice_cstr self);
mutslice(ucodepoint) : void drop_mutslice_ucodepoint(__attribute__ ((unused)) mutslice_ucodepoint self);
mutslice(utf8char)   : void drop_mutslice_utf8char(__attribute__ ((unused)) mutslice_utf8char self);
slice(CStr)          : void drop_slice_CStr(__attribute__ ((unused)) slice_CStr self);
slice(cstr)          : void drop_slice_cstr(__attribute__ ((unused)) slice_cstr self);
slice(ucodepoint)    : void drop_slice_ucodepoint(__attribute__ ((unused)) slice_ucodepoint self);
slice(utf8char)      : void drop_slice_utf8char(__attribute__ ((unused)) slice_utf8char self);
ucodepoint           : void drop_ucodepoint(__attribute__ ((unused)) ucodepoint c);
```

## resize {#two_resize}

```C
resize(v, oldlen, newlen)
```

Expects an array as the first argument, and the current length of
the array and the desired new length. Returns a new array of the
desired new length. If the new length is shorter than the old
length, the slots that are freed are `drop`ped, if the new length
is larger, then the new slots are filled in with blanks (zero
values, NULL pointers, or similar).

Members:

```C
Option(String)* : Option(String)* resize_Option_Strings(
 Option(String)* ary, size_t oldlen, size_t newlen
 );
cstr*           : cstr* resize_cstrs(cstr* ary, size_t oldlen, size_t newlen);
float*          : float* resize_floats(float* ary, size_t oldlen, size_t newlen);
int*            : int* resize_ints(int* ary, size_t oldlen, size_t newlen);
```

## drop_array {#two_drop_array}

```C
drop_array(v, len)
```

Frees the resources held by the given array,
including all the values contained in the array (including
resources held by contained values, recursively). For arrays
holding pointers, array slots containing the NULL pointer are
skipped.

Members:

```C
Option(String)* : void drop_Option_Strings(Option(String)* ary, size_t len);
cstr*           : void drop_cstrs(cstr* ary, size_t len);
```

## equal {#two_equal}

```C
equal(a, b)
```

Takes two values of the same type and returns a `bool`. Returns
`true` if `a` and `b` are structurally equivalent.

Members:

```C
CStr*                              : bool equal_CStr(const CStr *a, const CStr *b);
Color                              : bool equal_move_Color(Color a, Color b);
Color*                             : bool equal_Color(const Color *a, const Color *b);
Option(String)*                    : bool equal_Option_String(const Option_String *a, const Option_String *b);
Option(char)                       : bool equal_move_Option_char(Option_char a, Option_char b);
Option(char)*                      : bool equal_Option_char(const Option_char *a, const Option_char *b);
Option(cstr)*                      : bool equal_Option_cstr(const Option_cstr *a, const Option_cstr *b);
Option(float)*                     : bool equal_Option_float(const Option_float *a, const Option_float *b);
Option(int)*                       : bool equal_Option_int(const Option_int *a, const Option_int *b);
Option(ucodepoint)                 : bool equal_move_Option_ucodepoint(Option_ucodepoint a, Option_ucodepoint b);
Option(ucodepoint)*                : bool equal_Option_ucodepoint(const Option_ucodepoint *a, const Option_ucodepoint *b);
Option(utf8char)                   : bool equal_move_Option_utf8char(Option_utf8char a, Option_utf8char b);
Option(utf8char)*                  : bool equal_Option_utf8char(const Option_utf8char *a, const Option_utf8char *b);
Result(String, SystemError)*       : bool equal_Result_String__SystemError(const Result_String__SystemError *a, const Result_String__SystemError *b);
Result(int, ParseError)*           : bool equal_Result_int__ParseError(const Result_int__ParseError *a, const Result_int__ParseError *b);
String*                            : bool equal_String(const String *a, const String *b);
Vec(CStr)*                         : bool equal_Vec_CStr(const Vec_CStr *a, const Vec_CStr *b);
Vec(Vec2)*                         : bool equal_Vec_Vec2(const Vec_Vec2 *a, const Vec_Vec2 *b);
Vec(char)*                         : bool equal_Vec_char(const Vec_char *a, const Vec_char *b);
Vec(cstr)*                         : bool equal_Vec_cstr(const Vec_cstr *a, const Vec_cstr *b);
Vec(double)*                       : bool equal_Vec_double(const Vec_double *a, const Vec_double *b);
Vec(float)*                        : bool equal_Vec_float(const Vec_float *a, const Vec_float *b);
Vec(int)*                          : bool equal_Vec_int(const Vec_int *a, const Vec_int *b);
Vec(ucodepoint)*                   : bool equal_Vec_ucodepoint(const Vec_ucodepoint *a, const Vec_ucodepoint *b);
Vec(utf8char)*                     : bool equal_Vec_utf8char(const Vec_utf8char *a, const Vec_utf8char *b);
bool                               : bool equal_move_bool(bool a, bool b);
bool*                              : bool equal_bool(const bool *a, const bool *b);
char                               : bool equal_move_char(const char a, const char b);
const CStr*                        : bool equal_CStr(const CStr *a, const CStr *b);
const Color*                       : bool equal_Color(const Color *a, const Color *b);
const Option(String)*              : bool equal_Option_String(const Option_String *a, const Option_String *b);
const Option(char)*                : bool equal_Option_char(const Option_char *a, const Option_char *b);
const Option(cstr)*                : bool equal_Option_cstr(const Option_cstr *a, const Option_cstr *b);
const Option(float)*               : bool equal_Option_float(const Option_float *a, const Option_float *b);
const Option(int)*                 : bool equal_Option_int(const Option_int *a, const Option_int *b);
const Option(ucodepoint)*          : bool equal_Option_ucodepoint(const Option_ucodepoint *a, const Option_ucodepoint *b);
const Option(utf8char)*            : bool equal_Option_utf8char(const Option_utf8char *a, const Option_utf8char *b);
const Result(String, SystemError)* : bool equal_Result_String__SystemError(const Result_String__SystemError *a, const Result_String__SystemError *b);
const Result(int, ParseError)*     : bool equal_Result_int__ParseError(const Result_int__ParseError *a, const Result_int__ParseError *b);
const String*                      : bool equal_String(const String *a, const String *b);
const Vec(CStr)*                   : bool equal_Vec_CStr(const Vec_CStr *a, const Vec_CStr *b);
const Vec(Vec2)*                   : bool equal_Vec_Vec2(const Vec_Vec2 *a, const Vec_Vec2 *b);
const Vec(char)*                   : bool equal_Vec_char(const Vec_char *a, const Vec_char *b);
const Vec(cstr)*                   : bool equal_Vec_cstr(const Vec_cstr *a, const Vec_cstr *b);
const Vec(double)*                 : bool equal_Vec_double(const Vec_double *a, const Vec_double *b);
const Vec(float)*                  : bool equal_Vec_float(const Vec_float *a, const Vec_float *b);
const Vec(int)*                    : bool equal_Vec_int(const Vec_int *a, const Vec_int *b);
const Vec(ucodepoint)*             : bool equal_Vec_ucodepoint(const Vec_ucodepoint *a, const Vec_ucodepoint *b);
const Vec(utf8char)*               : bool equal_Vec_utf8char(const Vec_utf8char *a, const Vec_utf8char *b);
const bool*                        : bool equal_bool(const bool *a, const bool *b);
const cstr*                        : bool equal_cstr(const cstr *a, const cstr *b);
const double*                      : bool equal_double(const double *a, const double *b);
const float*                       : bool equal_float(const float *a, const float *b);
const int*                         : bool equal_int(const int *a, const int *b);
const ucodepoint*                  : bool equal_ucodepoint(const ucodepoint *a, const ucodepoint *b);
const utf8char*                    : bool equal_utf8char(const utf8char *a, const utf8char *b);
cstr                               : bool equal_move_cstr(cstr a, cstr b);
cstr*                              : bool equal_cstr(const cstr *a, const cstr *b);
double                             : bool equal_move_double(const double a, const double b);
double*                            : bool equal_double(const double *a, const double *b);
float                              : bool equal_move_float(const float a, const float b);
float*                             : bool equal_float(const float *a, const float *b);
int                                : bool equal_move_int(const int a, const int b);
int*                               : bool equal_int(const int *a, const int *b);
ucodepoint                         : bool equal_move_ucodepoint(ucodepoint a, ucodepoint b);
ucodepoint*                        : bool equal_ucodepoint(const ucodepoint *a, const ucodepoint *b);
utf8char                           : bool equal_move_utf8char(utf8char a, utf8char b);
utf8char*                          : bool equal_utf8char(const utf8char *a, const utf8char *b);
```

## some {#two_some}

```C
some(v)
```

Takes a value of some type `T` and returns a `some` variant of
`Option(T)` containing the value.

Members:

```C
CStr   : Option_CStr some_CStr(const CStr val);
String : Option_String some_String(const String val);
cstr   : Option_cstr some_cstr(const cstr val);
double : Option_double some_double(const double val);
float  : Option_float some_float(const float val);
int    : Option_int some_int(const int val);
u64    : Option_u64 some_u64(const u64 val);
u8     : Option_u8 some_u8(const u8 val);
```

## none {#two_none}

```C
none(T)
```

Returns the none variant of `Option(T)` for the given
T. Equivalent to `none_T()` using the type name of T, but
`none(T)` allows T to also be a `typeof` expression.

Members:

```C
CStr   : Option_CStr none_CStr();
String : Option_String none_String();
cstr   : Option_cstr none_cstr();
double : Option_double none_double();
float  : Option_float none_float();
int    : Option_int none_int();
u64    : Option_u64 none_u64();
u8     : Option_u8 none_u8();
```

## unwrap {#two_unwrap}

```C
unwrap(v)
```

Takes a wrapper for some type `T` (like `Option(T)`, or `Result(T,
E)`) and returns the contained value of type `T` if possible, or
aborts if not possible. This moves the value, i.e. the wrapper
is consumed.

Example:

```C
Option(CStr) maybe_name = get_CStr();
// maybe_name can be a `none(CStr)` or e.g. `some("Alex")`.
CStr name = unwrap(maybe_name);
// Now we're guaranteed to have a CStr in `name`, "Alex" if we
// had the second case above. But if `maybe_name` was a none
// then the program has terminated by now instead.
```

Members:

```C
Option(CStr)                          : CStr unwrap_Option_CStr(const Option_CStr s);
Option(String)                        : String unwrap_Option_String(const Option_String s);
Option(char)                          : char unwrap_Option_char(const Option_char s);
Option(cstr)                          : cstr unwrap_Option_cstr(const Option_cstr s);
Option(double)                        : double unwrap_Option_double(const Option_double s);
Option(float)                         : float unwrap_Option_float(const Option_float s);
Option(int)                           : int unwrap_Option_int(const Option_int s);
Option(u64)                           : u64 unwrap_Option_u64(const Option_u64 s);
Option(u8)                            : u8 unwrap_Option_u8(const Option_u8 s);
Option(ucodepoint)                    : ucodepoint unwrap_Option_ucodepoint(const Option_ucodepoint s);
Option(utf8char)                      : utf8char unwrap_Option_utf8char(const Option_utf8char s);
Result(String, SystemError)           : String unwrap_Result_String__SystemError(const Result_String__SystemError s);
Result(Unit, UnicodeError)            : Unit unwrap_Result_Unit__UnicodeError(const Result_Unit__UnicodeError s);
Result(Vec(ucodepoint), UnicodeError) : Vec_ucodepoint unwrap_Result_Vec_ucodepoint__UnicodeError(const Result_Vec_ucodepoint__UnicodeError s);
Result(Vec(utf8char), UnicodeError)   : Vec_utf8char unwrap_Result_Vec_utf8char__UnicodeError(const Result_Vec_utf8char__UnicodeError s);
Result(float, ParseError)             : float unwrap_Result_float__ParseError(const Result_float__ParseError s);
Result(int, ParseError)               : int unwrap_Result_int__ParseError(const Result_int__ParseError s);
Result(size_t, UnicodeError)          : size_t unwrap_Result_size_t__UnicodeError(const Result_size_t__UnicodeError s);
Result(ucodepoint, UnicodeError)      : ucodepoint unwrap_Result_ucodepoint__UnicodeError(const Result_ucodepoint__UnicodeError s);
```

## deref {#two_deref}

```C
deref(v)
```

Dereferencing a wrapper type ('smart pointer') to the simpler
contained type; the result is of a reference type (not owned).

Example:

```C
CStr s = unwrap(filecontents_CStr(path));
cstr s1 = deref(&s);
```

Members:

```C
CStr* : cstr deref_CStr(const CStr *s);
```

## type_name {#two_type_name}

```C
type_name(e)
```

Returns the name of the type of `e` as a string constant (cstr).

Members:

```C
Line2                       : "Line2";
Option(String)              : "Option(String)";
Option(cstr)                : "Option(cstr)";
Option(double)              : "Option(double)";
Option(float)               : "Option(float)";
Option(int)                 : "Option(int)";
Option(u64)                 : "Option(u64)";
Option(u8)                  : "Option(u8)";
Rect2                       : "Rect2";
Result(String, SystemError) : "Result(String, SystemError)";
Result(int, ParseError)     : "Result(int, ParseError)";
String                      : "String";
Vec(CStr)                   : "Vec(CStr)";
Vec(Vec2)                   : "Vec(Vec2)";
Vec(char)                   : "Vec(char)";
Vec(cstr)                   : "Vec(cstr)";
Vec(double)                 : "Vec(double)";
Vec(float)                  : "Vec(float)";
Vec(int)                    : "Vec(int)";
Vec(ucodepoint)             : "Vec(ucodepoint)";
Vec(utf8char)               : "Vec(utf8char)";
Vec2                        : "Vec2";
Vec3                        : "Vec3";
cstr                        : "cstr";
double                      : "double";
float                       : "float";
int                         : "int";
mutslice(CStr)              : "mutslice(CStr)";
mutslice(cstr)              : "mutslice(cstr)";
mutslice(ucodepoint)        : "mutslice(ucodepoint)";
mutslice(utf8char)          : "mutslice(utf8char)";
slice(CStr)                 : "slice(CStr)";
slice(cstr)                 : "slice(cstr)";
slice(ucodepoint)           : "slice(ucodepoint)";
slice(utf8char)             : "slice(utf8char)";
u64                         : "u64";
u8                          : "u8";
ucodepoint                  : "ucodepoint";
unsigned int                : "uint";
```

## equal_array {#two_equal_array}

```C
equal_array(array1, len1, array2, len2)
```

Returns true iff len1 == len2 and for every index,
`equal(array1[i], array2[i])` is true.

Members:

```C
String : bool equal_array_String(String* a, size_t alen, String* b, size_t blen);
char   : bool equal_array_char(char* a, size_t alen, char* b, size_t blen);
cstr   : bool equal_array_cstr(cstr* a, size_t alen, cstr* b, size_t blen);
double : bool equal_array_double(double* a, size_t alen, double* b, size_t blen);
float  : bool equal_array_float(float* a, size_t alen, float* b, size_t blen);
int    : bool equal_array_int(int* a, size_t alen, int* b, size_t blen);
u64    : bool equal_array_u64(u64* a, size_t alen, u64* b, size_t blen);
uint   : bool equal_array_uint(uint* a, size_t alen, uint* b, size_t blen);
```

## push {#two_push}

```C
push(coll, val)
```

Push a value onto the end of a collection. For Vec and String.

Members:

```C
Vec(CStr)*       : void push_Vec_CStr(Vec_CStr *self, CStr value);
Vec(Vec2)*       : void push_Vec_Vec2(Vec_Vec2 *self, Vec2 value);
Vec(char)*       : void push_Vec_char(Vec_char *self, char value);
Vec(cstr)*       : void push_Vec_cstr(Vec_cstr *self, cstr value);
Vec(double)*     : void push_Vec_double(Vec_double *self, double value);
Vec(float)*      : void push_Vec_float(Vec_float *self, float value);
Vec(int)*        : void push_Vec_int(Vec_int *self, int value);
Vec(ucodepoint)* : void push_Vec_ucodepoint(Vec_ucodepoint *self, ucodepoint value);
Vec(utf8char)*   : void push_Vec_utf8char(Vec_utf8char *self, utf8char value);
```

## pop {#two_pop}

```C
pop(coll)
```

Pop a value off the end of a collection. For Vec and String.

Members:

```C
Vec(CStr)*       : Option_CStr pop_Vec_CStr(Vec_CStr *self);
Vec(Vec2)*       : Option_Vec2 pop_Vec_Vec2(Vec_Vec2 *self);
Vec(char)*       : Option_char pop_Vec_char(Vec_char *self);
Vec(cstr)*       : Option_cstr pop_Vec_cstr(Vec_cstr *self);
Vec(double)*     : Option_double pop_Vec_double(Vec_double *self);
Vec(float)*      : Option_float pop_Vec_float(Vec_float *self);
Vec(int)*        : Option_int pop_Vec_int(Vec_int *self);
Vec(ucodepoint)* : Option_ucodepoint pop_Vec_ucodepoint(Vec_ucodepoint *self);
Vec(utf8char)*   : Option_utf8char pop_Vec_utf8char(Vec_utf8char *self);
```

## append {#two_append}

```C
append(coll1, coll2)
```

Append the items from coll2 onto the end of coll1, leaving coll2
empty. For Vec and String.

Members:

```C
String*          : void append_String_String(String *a, String *b);
Vec(CStr)*       : void append_Vec_CStr(Vec_CStr *self, Vec_CStr *other);
Vec(Vec2)*       : void append_Vec_Vec2(Vec_Vec2 *self, Vec_Vec2 *other);
Vec(char)*       : void append_Vec_char(Vec_char *self, Vec_char *other);
Vec(cstr)*       : void append_Vec_cstr(Vec_cstr *self, Vec_cstr *other);
Vec(double)*     : void append_Vec_double(Vec_double *self, Vec_double *other);
Vec(float)*      : void append_Vec_float(Vec_float *self, Vec_float *other);
Vec(int)*        : void append_Vec_int(Vec_int *self, Vec_int *other);
Vec(ucodepoint)* : void append_Vec_ucodepoint(Vec_ucodepoint *self, Vec_ucodepoint *other);
Vec(utf8char)*   : void append_Vec_utf8char(Vec_utf8char *self, Vec_utf8char *other);
```

## append_move {#two_append_move}

```C
append_move(coll1, coll2)
```

Append the items from coll2 onto the end of coll1, consuming
coll2.

Members:

```C
String* : void append_move_String_String(String *a, String b);
```

## len {#two_len}

```C
len(coll)
```

Give the length of a given collection. It always reports the
number of identically-sized storage locations, which means that
for String, it reports the number of bytes (C char), not the
number of unicode codepoints.

Members:

```C
String*                     : size_t len_String(const String *s);
Vec(CStr)*                  : size_t len_Vec_CStr(const Vec_CStr *self);
Vec(Vec2)*                  : size_t len_Vec_Vec2(const Vec_Vec2 *self);
Vec(char)*                  : size_t len_Vec_char(const Vec_char *self);
Vec(cstr)*                  : size_t len_Vec_cstr(const Vec_cstr *self);
Vec(double)*                : size_t len_Vec_double(const Vec_double *self);
Vec(float)*                 : size_t len_Vec_float(const Vec_float *self);
Vec(int)*                   : size_t len_Vec_int(const Vec_int *self);
Vec(ucodepoint)*            : size_t len_Vec_ucodepoint(const Vec_ucodepoint *self);
Vec(utf8char)*              : size_t len_Vec_utf8char(const Vec_utf8char *self);
const String*               : size_t len_String(const String *s);
const Vec(CStr)*            : size_t len_Vec_CStr(const Vec_CStr *self);
const Vec(Vec2)*            : size_t len_Vec_Vec2(const Vec_Vec2 *self);
const Vec(char)*            : size_t len_Vec_char(const Vec_char *self);
const Vec(cstr)*            : size_t len_Vec_cstr(const Vec_cstr *self);
const Vec(double)*          : size_t len_Vec_double(const Vec_double *self);
const Vec(float)*           : size_t len_Vec_float(const Vec_float *self);
const Vec(int)*             : size_t len_Vec_int(const Vec_int *self);
const Vec(ucodepoint)*      : size_t len_Vec_ucodepoint(const Vec_ucodepoint *self);
const Vec(utf8char)*        : size_t len_Vec_utf8char(const Vec_utf8char *self);
const mutslice(CStr)*       : size_t len_mutslice_CStr(const mutslice_CStr *self);
const mutslice(char)*       : size_t len_mutslice_char(const mutslice_char *self);
const mutslice(cstr)*       : size_t len_mutslice_cstr(const mutslice_cstr *self);
const mutslice(int)*        : size_t len_mutslice_int(const mutslice_int *self);
const mutslice(ucodepoint)* : size_t len_mutslice_ucodepoint(const mutslice_ucodepoint *self);
const mutslice(utf8char)*   : size_t len_mutslice_utf8char(const mutslice_utf8char *self);
const slice(CStr)*          : size_t len_slice_CStr(const slice_CStr *self);
const slice(char)*          : size_t len_slice_char(const slice_char *self);
const slice(cstr)*          : size_t len_slice_cstr(const slice_cstr *self);
const slice(int)*           : size_t len_slice_int(const slice_int *self);
const slice(ucodepoint)*    : size_t len_slice_ucodepoint(const slice_ucodepoint *self);
const slice(utf8char)*      : size_t len_slice_utf8char(const slice_utf8char *self);
mutslice(CStr)*             : size_t len_mutslice_CStr(const mutslice_CStr *self);
mutslice(char)*             : size_t len_mutslice_char(const mutslice_char *self);
mutslice(cstr)*             : size_t len_mutslice_cstr(const mutslice_cstr *self);
mutslice(int)*              : size_t len_mutslice_int(const mutslice_int *self);
mutslice(ucodepoint)*       : size_t len_mutslice_ucodepoint(const mutslice_ucodepoint *self);
mutslice(utf8char)*         : size_t len_mutslice_utf8char(const mutslice_utf8char *self);
slice(CStr)*                : size_t len_slice_CStr(const slice_CStr *self);
slice(char)*                : size_t len_slice_char(const slice_char *self);
slice(cstr)*                : size_t len_slice_cstr(const slice_cstr *self);
slice(int)*                 : size_t len_slice_int(const slice_int *self);
slice(ucodepoint)*          : size_t len_slice_ucodepoint(const slice_ucodepoint *self);
slice(utf8char)*            : size_t len_slice_utf8char(const slice_utf8char *self);
```

## cstr {#two_cstr}

```C
cstr(v)
```

Give a cstr to the given character collection. Note that this may
return an error if the collection contains `'\0'` bytes.

Members:

```C
CStr*     : cstr cstr_CStr(CStr *s);
String*   : Option(cstr) cstr_String(String *s);
utf8char* : cstr cstr_utf8char(const utf8char *c);
```

## fprintln {#two_fprintln}

```C
fprintln(out, v)
```

Like println but printing to `out`.

(Currently only defined for types for which `unwrap` is defined,
to be used for error messaging. Todo: define `println` in terms of
`fprintln` and thus share implementations.)

Members:

```C
CStrError*     : int fprintln_CStrError(FILE *out, const CStrError *e);
DecodingError* : int fprintln_DecodingError(FILE* out, const DecodingError* e);
ParseError*    : int fprintln_ParseError(FILE* out, const ParseError *e);
String*        : int fprintln_String(FILE *out, const String *s);
SystemError*   : int fprintln_SystemError(FILE* out, const SystemError *e);
UnicodeError*  : int fprintln_UnicodeError(FILE* out, const UnicodeError* e);
VecError*      : int fprintln_VecError(FILE *out, const VecError *e);
```

## get_utf8char {#two_get_utfQeightEchar}

```C
get_utf8char(s, idx)
```

Get a `utf8char` from a collection. DEPRECATED, use get_ucodepoint
instead.

Members:

```C
String* : Option(utf8char) get_utf8char_String(const String *s, size_t idx);
```

## get_ucodepoint {#two_get_ucodepoint}

```C
get_ucodepoint(s, idx)
```

Get a `ucodepoint` from a collection.

Members:

```C
String* : Option(ucodepoint) get_ucodepoint_String(const String *s, size_t idx);
```

## clear {#two_clear}

```C
clear(s)
```

Clear a collection or similar thing (make it empty).

Members:

```C
SDL_Renderer*    : clear_SDL_Renderer /* evil? */;
String*          : void clear_String(String *s);
Vec(CStr)*       : void clear_Vec_CStr(Vec_CStr *self);
Vec(Vec2)*       : void clear_Vec_utf8char(Vec_utf8char *self);
Vec(char)*       : void clear_Vec_utf8char(Vec_utf8char *self);
Vec(cstr)*       : void clear_Vec_cstr(Vec_cstr *self);
Vec(double)*     : void clear_Vec_utf8char(Vec_utf8char *self);
Vec(float)*      : void clear_Vec_utf8char(Vec_utf8char *self);
Vec(int)*        : void clear_Vec_utf8char(Vec_utf8char *self);
Vec(ucodepoint)* : void clear_Vec_ucodepoint(Vec_ucodepoint *self);
Vec(utf8char)*   : void clear_Vec_utf8char(Vec_utf8char *self);
```

## read_until {#two_read_until}

```C
read_until(in, delimiter, buf, strip_delimiter, max_len)
```

Read items into buf until the delimiter or EOF is reached.

Members:

```C
\
             , Vec(ucodepoint)* : Result(size_t, UnicodeError) read_until_Vec_ucodepoint
    (CFile *in,
     ucodepoint delimiter,
     Vec(ucodepoint) *buf,
     bool strip_delimiter,
     size_t max_len);
```

## read_line {#two_read_line}

```C
read_line(in, buf, strip_delimiter, max_len)
```

Read items into buf until a newline character (`'\n'`) or EOF is
reached.

Members:

```C
\
             , Vec(ucodepoint)* : Result(size_t, UnicodeError) read_line_Vec_ucodepoint
    (CFile *in,
     Vec(ucodepoint) *buf,
     bool strip_delimiter,
     size_t max_len);
```

## get_ucodepoint_unlocked {#two_get_ucodepoint_unlocked}

```C
get_ucodepoint_unlocked(in)
```

Read an ucodepoint from `in`.

Members:

```C
CFile*               : Result(Option(ucodepoint), UnicodeError) get_ucodepoint_unlocked_CFile(CFile *in);
SliceIterator(char)* : Result(Option(ucodepoint), UnicodeError) get_ucodepoint_unlocked_SliceIterator_char(
    SliceIterator(char) *in);
```

## new_String_from {#two_new_String_from}

```C
new_String_from(v)
```

Create a String from various types. (Ideally the same as
`new_from(String, v)`, but that one has fewer entries.)

Members:

```C
CStr        : String new_String_from_CStr(CStr s);
char*       : String new_String_from_cstr(cstr s);
cstr        : String new_String_from_cstr(cstr s);
int         : String new_String_from_move_int(int v);
size_t      : String new_String_from_move_size_t(size_t v);
slice(char) : String new_String_from_slice_char(slice(char) s);
```

## at {#two_at}

```C
at(v, idx)
```

Get a reference to the element at position `i`. Aborts if `i` is
behind the end of the collection. (XX todo: If you are not sure if
`i` is valid, use `get` instead.)

Members:

```C
Vec(Vec2)*            : const Vec2* at_Vec_Vec2(const Vec_Vec2 *self, size_t idx);
Vec(char)*            : const char* at_Vec_char(const Vec_char *self, size_t idx);
Vec(double)*          : const double* at_Vec_double(const Vec_double *self, size_t idx);
Vec(float)*           : const float* at_Vec_float(const Vec_float *self, size_t idx);
Vec(int)*             : const int* at_Vec_int(const Vec_int *self, size_t idx);
const Vec(Vec2)*      : const Vec2* at_Vec_Vec2(const Vec_Vec2 *self, size_t idx);
const Vec(char)*      : const char* at_Vec_char(const Vec_char *self, size_t idx);
const Vec(double)*    : const double* at_Vec_double(const Vec_double *self, size_t idx);
const Vec(float)*     : const float* at_Vec_float(const Vec_float *self, size_t idx);
const Vec(int)*       : const int* at_Vec_int(const Vec_int *self, size_t idx);
const mutslice(char)* : const char* at_mutslice_char(const mutslice_char *self, size_t idx);
const mutslice(int)*  : const int* at_mutslice_int(const mutslice_int *self, size_t idx);
const slice(char)*    : const char* at_slice_char(const slice_char *self, size_t idx);
const slice(int)*     : const int* at_slice_int(const slice_int *self, size_t idx);
mutslice(char)*       : const char* at_mutslice_char(const mutslice_char *self, size_t idx);
mutslice(int)*        : const int* at_mutslice_int(const mutslice_int *self, size_t idx);
slice(char)*          : const char* at_slice_char(const slice_char *self, size_t idx);
slice(int)*           : const int* at_slice_int(const slice_int *self, size_t idx);
```

## set {#two_set}

```C
set(v, idx, val)
```

Move the given `val` into the slot with the given `idx`,
replacing the value that was there previously. Aborts if the index
isn't smaller than the current `len` of the vector.

Members:

```C
Vec(Vec2)*            : void set_Vec_Vec2(Vec_Vec2 *self, size_t index, Vec2 value);
Vec(char)*            : void set_Vec_char(Vec_char *self, size_t index, char value);
Vec(double)*          : void set_Vec_double(Vec_double *self, size_t index, double value);
Vec(float)*           : void set_Vec_float(Vec_float *self, size_t index, float value);
Vec(int)*             : void set_Vec_int(Vec_int *self, size_t index, int value);
const Vec(Vec2)*      : void set_Vec_Vec2(Vec_Vec2 *self, size_t index, Vec2 value);
const Vec(char)*      : void set_Vec_char(Vec_char *self, size_t index, char value);
const Vec(double)*    : void set_Vec_double(Vec_double *self, size_t index, double value);
const Vec(float)*     : void set_Vec_float(Vec_float *self, size_t index, float value);
const Vec(int)*       : void set_Vec_int(Vec_int *self, size_t index, int value);
const mutslice(char)* : void set_mutslice_char(mutslice_char *self, size_t index, char value);
const mutslice(int)*  : void set_mutslice_int(mutslice_int *self, size_t index, int value);
mutslice(char)*       : void set_mutslice_char(mutslice_char *self, size_t index, char value);
mutslice(int)*        : void set_mutslice_int(mutslice_int *self, size_t index, int value);
```

## slice_of {#two_slice_of}

```C
slice_of(v, range)
```

Create a slice of various collection types. A slice is borrowing a
range of items from the original collection. Careful, these
"always succeed": if the range is not applicable, they abort.

Members:

```C
Vec(Vec2)*            : slice_Vec2 slice_of_Vec_Vec2(const Vec_Vec2 *self, Range range);
Vec(char)*            : slice_char slice_of_Vec_char(const Vec_char *self, Range range);
Vec(double)*          : slice_double slice_of_Vec_double(const Vec_double *self, Range range);
Vec(float)*           : slice_float slice_of_Vec_float(const Vec_float *self, Range range);
Vec(int)*             : slice_int slice_of_Vec_int(const Vec_int *self, Range range);
const Vec(Vec2)*      : slice_Vec2 slice_of_Vec_Vec2(const Vec_Vec2 *self, Range range);
const Vec(char)*      : slice_char slice_of_Vec_char(const Vec_char *self, Range range);
const Vec(double)*    : slice_double slice_of_Vec_double(const Vec_double *self, Range range);
const Vec(float)*     : slice_float slice_of_Vec_float(const Vec_float *self, Range range);
const Vec(int)*       : slice_int slice_of_Vec_int(const Vec_int *self, Range range);
const mutslice(char)* : slice_char slice_of_mutslice_char(const mutslice_char *self, Range range);
const mutslice(int)*  : slice_int slice_of_mutslice_int(const mutslice_int *self, Range range);
const slice(char)*    : slice_char slice_of_slice_char(const slice_char *self, Range range);
const slice(int)*     : slice_int slice_of_slice_int(const slice_int *self, Range range);
mutslice(char)*       : slice_char slice_of_mutslice_char(const mutslice_char *self, Range range);
mutslice(int)*        : slice_int slice_of_mutslice_int(const mutslice_int *self, Range range);
slice(char)*          : slice_char slice_of_slice_char(const slice_char *self, Range range);
slice(int)*           : slice_int slice_of_slice_int(const slice_int *self, Range range);
```

## mutslice_of {#two_mutslice_of}

```C
mutslice_of(v, range)
```

Create a mutable slice of various collection types. A slice is borrowing a
range of items from the original collection. Careful, these
"always succeed": if the range is not applicable, they abort.

Members:

```C
Vec(Vec2)*            : mutslice_Vec2 mutslice_of_Vec_Vec2(Vec_Vec2 *self, Range range);
Vec(char)*            : mutslice_char mutslice_of_Vec_char(Vec_char *self, Range range);
Vec(double)*          : mutslice_double mutslice_of_Vec_double(Vec_double *self, Range range);
Vec(float)*           : mutslice_float mutslice_of_Vec_float(Vec_float *self, Range range);
Vec(int)*             : mutslice_int mutslice_of_Vec_int(Vec_int *self, Range range);
const Vec(Vec2)*      : mutslice_Vec2 mutslice_of_Vec_Vec2(Vec_Vec2 *self, Range range);
const Vec(char)*      : mutslice_char mutslice_of_Vec_char(Vec_char *self, Range range);
const Vec(double)*    : mutslice_double mutslice_of_Vec_double(Vec_double *self, Range range);
const Vec(float)*     : mutslice_float mutslice_of_Vec_float(Vec_float *self, Range range);
const Vec(int)*       : mutslice_int mutslice_of_Vec_int(Vec_int *self, Range range);
const mutslice(char)* : mutslice_char mutslice_of_mutslice_char(mutslice_char *self, Range range);
const mutslice(int)*  : mutslice_int mutslice_of_mutslice_int(mutslice_int *self, Range range);
mutslice(char)*       : mutslice_char mutslice_of_mutslice_char(mutslice_char *self, Range range);
mutslice(int)*        : mutslice_int mutslice_of_mutslice_int(mutslice_int *self, Range range);
```

## get_slice_of {#two_get_slice_of}

```C
get_slice_of(v, range)
```

Create a slice of various collection types. A slice is borrowing a
range of items from the original collection. These return None if
the given range is not applicable.

Members:

```C
String*       : Option(strslice) get_slice_of_String(const String *s, Range range);
const String* : Option(strslice) get_slice_of_String(const String *s, Range range);
```

# Macros

## DBG {#three_DBG}

```C
DBG(expr)
```

"DeBuG": print the expression `expr` and the value it evaluated
to, for debugging purposes (calls `print_debug` on the value).

## DBGA {#three_DBGA}

```C
DBGA(expr, len)
```

`DBG` `A`rray: print the expression `expr` and the array value
it evaluated to, for debugging purposes (calls
`print_debug_array`). `len` must give the length of the array.

## MAIN {#three_MAIN}

```C
MAIN(mainfunction)
```

`MAIN` takes the name of the function to run when the program
starts. `mainfunction` receives a `slice` of `cstr` values which
are holding the program name in position 0 (usually, but not
actually guaranteed) and then the program arguments, and must
return a Result. If it returns an Err, the program will exit with
exit code 1, if it returns Ok, with exit code 0. (The Ok value
itself is currently being ignored.)

`MAIN` defines the function `main` (hence `mainfunction` cannot be
called `main`).

```C
Result(Unit, UnicodeError) run(slice(cstr) argv) {
    ...
}

MAIN(run);
```

<hr>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
