#!/usr/bin/env perl

my $copyright= <<'COPYRIGHT';
# Copyright 2023 by Christian Jaeger <ch@christianjaeger.ch>
# Published under the same terms as perl itself
COPYRIGHT

use strict;
use utf8;
use warnings;
use warnings FATAL => 'uninitialized';
use experimental 'signatures';

my ($email_full)= $copyright=~ / by ([^\n]*)/s;

my ($mydir, $myname);
BEGIN {
    $0=~ /(.*?)([^\/]+)\z/s or die "?";
    ($mydir, $myname)=($1,$2);
}

#use Chj::ruse;
use FP::Show; use FP::Repl; use FP::Repl::Trap;#
use Getopt::Long;
use Chj::IO::Command;
use Chj::xperlfunc ":all";
use Chj::xIOUtil "xputfile_utf8";
use Chj::chompspace;

sub usage {
    print STDERR map{"$_\n"} @_ if @_;
    print "$myname

  Extract API documentation, for all the items following a block of
  lines starting with '///', as well as a single optional '//!' block
  per file (usually near the top).

  ($email_full)
";
exit (@_ ? 1 : 0);
}

our $verbose=0;
#our $opt_dry;
GetOptions("verbose"=> \$verbose,
	   "help"=> sub{usage},
	   #"dry-run"=> \$opt_dry,
	   ) or exit 1;
usage if @ARGV;


sub source_prototypes($source, $symbol) {
    $source=~ /
        (?: ^ | ; | \} ) # last item
        \s*
        # \n  can't require that, it's not in generated code in -E output
        (\w+ [^;{}]* [^\(] \b \Q$symbol\E \s*\( [^;{}]* ) \{
    /sgx
}

sub prototype_from_E_cleanup($s) {
    $s=~ s/\bstatic\b(?:\s*UNUSED\b)?//s;
    $s=~ s/\b__attribute__\s*\(\(.*?\)\)//s;
    $s=~ s/ +/ /g;
    $s=~ s/\b_Bool\b/bool/sg;
    chompspace $s
}

my $std_prototypes = +{
    putchar=> "int putchar(int c)",
    free=> "void free(void *ptr)",
};


package GenericsMember {
    use FP::Struct ["key"]=> qw(FP::Struct::Show);
    _END_
}
package GenericsOther {
    use FP::Struct ["expr"]=> qw(GenericsMember);
    sub code($self, $symbol_lookup) { $self->expr }
    _END_
}
package GenericsFunction {
    use FP::Struct ["symbol"]=> qw(GenericsMember);
    sub code($self, $symbol_lookup) {
        my $symbol = $self->symbol;
        $symbol_lookup->($symbol)
    }
    _END_
}


package DocEntry {
    use Chj::chompspace;
    use FP::PureArray;
    
    use FP::Struct [
        "headerpath",
        "bare_docs",
        "bare_prototype",
        "terminator",
        ]=> qw(FP::Struct::Show);

    sub docs($self) {
        my $s = $self->bare_docs;
        $s=~ s{(^|\n)/// ?}{$1}sg;
        $s =~ s{\s+\z}{}s;
        $s
    }

    sub prototype($self) {
        my $s = $self->bare_prototype;
        $s =~ s{^\s+}{}s;
        $s =~ s{\s+\z}{}s;
        # Remove #define, or leave it in? At least canonicalize it
        #$s =~ s{^#\s*define\s+}{#define }s;
        $s =~ s{^#\s*define\s+}{}s;
        $s
    }

    sub symbol($self) {
        my $s = $self->bare_prototype;
        if ($s=~ m{^\s*#\s*define\s+(\w+)}) {
            $1
        } elsif ($s=~ m{^typedef\s+struct\s+(\w+)}) {
            $1
        } elsif ($s=~ m{^typedef\b.*\b(\w+)\s*$}) {
            $1
        } else {
            # Now it gets hard! ucfirst really disambiguates here? !
            if ($s=~ m{ ([a-z]\w*)\s*\(}) {
                $1
            } elsif ($s=~ m{^ \s* const \s+ \S+ \s+ ([a-zA-Z_]\w*) \s*
                              =[^=] }sx) {
                # global constants
                $1
            } else {
                die "no match"
            }
        }
    }

    sub kind($self) {
        my $p = $self->bare_prototype;
        if ($p =~ /^\s*#\s*define\s*(\S+)/) {
            my $definitionfirst = $1;
            if ($self->terminator =~ /_Generic/) {
                "2 Generic functions"
            } else {
                #if ($definitionfirst =~ m{\(}) {
                    "3 Macros"
                #} else {
                #    "Constants"
                #}
            }
        } elsif ($p=~ m{^typedef\b(\s+struct\b)?}) {
            $1 ? "0 Types" : "0.1 Type aliases"
        } elsif ($p=~ m{^ \s* const \s+ \S+ \s+ ([a-zA-Z_]\w*) \s*
                          =[^=] }sx) {
            "0.5 Constants"
        } else {
            "1 Normal functions"
        }
    }

    sub generic_members($self) {
        my $term = $self->terminator;
        if ($term=~ s/.*?_Generic//s) {
            my @m = $term =~ m{,\s*([^:]+:.*?)\\\n}g;
            my @e = map {
                my $s = $_;
                if ($s=~ s/^(.*?)://s) {
                    my $key = chompspace($1);
                    $s=~ s/^\s+//s;
                    $s=~ s/\s+\z//s;
                    $s=~ /_Generic/ ? () : do {
                        my $class = $s=~ m{^[a-zA-Z_]\w*\z}s ?
                            "GenericsFunction" : "GenericsOther";
                        $class->new($key, $s)
                    }
                } else {
                    ()
                }
            } @m;
        } else {
            ()
        }
    }
    
    sub markdown($self, $symbol_lookup) {
        my @code = map {
            "$_\n"
        } split /\n/, $self->prototype;
        my @docs = map {
            "$_\n"
        } split /\n/, $self->docs;
        my @generic_members = $self->generic_members;
        my $generic_members = @generic_members ? do {
            my $m = purearray(@generic_members);
            my $maxlen = $m->map(sub($o){length $o->key})->max;
            my $lines = $m->map(
                sub($o) {
                    my $k = $o->key;
                    my $sp = $maxlen - length $k;
                    $k.(" "x$sp)." : "
                        .chompspace($o->code($symbol_lookup)).";\n"
                });
            #use FP::Repl; repl;
            join("",
                 (
                  "\n",
                  "Members:\n",
                  "\n",
                  "```C\n",
                  $lines->sort->values,
                  "```\n",
                 )
                )
        } : "";
        
        join("",
             (
              "## " . $self->symbol . "\n",
              "\n",
              "```C\n",
              @code,
              "```\n",
              "",
              @docs,
              $generic_members
             ))
    }
    _END_
}

my @headerfiles = do {
    my $s = Chj::IO::Command->new_sender(qw(gls-of-suffix h));
    my @l = $s->xreadline;
    $s->xxfinish;
    chomp @l;
    @l
};

my $DOCWARNING = "<!-- THIS FILE WAS AUTO-GENERATED by $myname. DO NOT EDIT! -->\n\n";

sub do_append_whitespace_footer($docref) {
    # Append superfluous space at the end so that it can jump to the
    # right place?
    $$docref .= "<hr>\n";
    for (1..30) {
        $$docref .= "<p>&nbsp;</p>\n";
    }
}

sub output_path($inpath) {
    "doc-output/$inpath.md"
}

my $tripleslashline = qr{(?: /// [^\n]* \n )}xs;
my $topslashline = qr{(?: //\! [^\n]* \n )}xs;
my $emptyline = qr{(?: [ \t]* \n )}xs;
my $docblock = qr{ (?: $emptyline $tripleslashline+  )+ }xs;
my $topblock = qr{ (?: (?: ^ | $emptyline) $topslashline+ )+ }xs;

sub filedocs ($path) {
    my $s = xgetfile_utf8 $path;
    my %items;
    while ($s=~ m{
               ($docblock)
               $emptyline?

               # captured code:
               (
                  # struct definition
                  typedef\s+struct\s+ \w+ \s+\{.*?\}\s* \w+(?=;)
                    # ^ the first and second \w+ block should be identical, todo?
                  |
                  .*? # simply whatever up to the terminator
               )
               # terminator:
               (
                   \{                       # function
                  | ;                        # e.g. typedef
                  | \\ (?: \s* _Generic .*?[^\\]\n)?    # generic
                  | (?= \n (?: /// | \# | [ \t]*\n ))
               )
           }xsg) {
        my $e = DocEntry->new( $path, $1, $2, $3 );
        push @{$items{$e->kind}}, $e;
    }
    my ($maybe_topblock) = $s=~ m{ ($topblock) }xs;

    my $genfile = sub($symbol_lookup) {
        my $doc = $DOCWARNING;
        # $doc .= "# Documentation for $path\n\n";

        if (defined $maybe_topblock) {
            my @lines = map {
                s{^//\! ?}{};
                s{\s+\z}{};
                "$_\n"
            } split /\n/, $maybe_topblock;
            $doc .= join("", @lines)."\n";
        }

        for my $key (sort keys %items) {
            my $items = $items{$key};
            my $subsection = $key;
            $subsection =~ s/^\d+(?:\.\d+)? +//;
            $doc .= "# $subsection\n\n";
            for my $item (@$items) {
                $doc .= $item->markdown($symbol_lookup)."\n";
            }
        }

        do_append_whitespace_footer(\$doc);

        my $outpath = output_path($path);
        xmkdir_p dirname($outpath);
        xputfile_utf8 $outpath, $doc;
    };
    (\%items, $genfile, $s)
}

my @itemss = map { [ filedocs($_) ] } @headerfiles;

{
    my %documented_headerfiles;
    my @genfiles; # generators for a .h.md file each
    my @s; # contents of a .h file each
    my $doc_Names = do {
        my $doc = ""; # part only
        my %items; # across all pages, by kind
        my %flatitems; # across all pages, directly
        for my $items_genfile (@itemss) {
            my ($items, $genfile, $s) = @$items_genfile;
            push @genfiles, $genfile;
            push @s, $s;
            # partial copy paste of this loop:
            for my $key (sort keys %$items) {
                my $items = $items->{$key};
                for my $item (@$items) {
                    my $symbol = $item->symbol;
                    die "duplicate symbol" if exists $items{$key}{$symbol};
                    $items{$key}{$symbol} = $item;
                    $flatitems{$symbol} = $item;
                }
            }
        }
        # Now %flatitems is filled and we can call the genfiles.  For
        # general symbol->prototype resolution, we need the -E output,
        # though (@s is not necessarily enough: `GENERATE_*`ed code
        # would not be found via my regexes in it).
        my $E = `clang -E -I. cj50.h`; $? == 0 or die "error";
        $E =~ s/^#.*$//mg;
        #use FP::Repl; repl;
        my $symbol_lookup = sub ($symbol) {
            if (defined (my $obj= $flatitems{$symbol})) {
                $obj->prototype
            } else {
                $std_prototypes->{$symbol} // do {
                    # need to go find it in the source code
                    my @prototypes;
                    for my $s (@s) {
                        push @prototypes, source_prototypes($s, $symbol);
                    }
                    if (@prototypes == 1) {
                        prototype_from_E_cleanup($prototypes[0])
                    } elsif (@prototypes) {
                        die "more than 1 match for symbol '$symbol'";
                    } else {
                        @prototypes = source_prototypes($E, $symbol);
                        if (@prototypes == 1) {
                            prototype_from_E_cleanup($prototypes[0])
                        } elsif (@prototypes) {
                            die "more than 1 match for symbol '$symbol'";
                        } else {
                            die "could not find symbol '$symbol'";
                        }
                    }
                }
            }
        };
        for my $genfile (@genfiles) {
            $genfile->($symbol_lookup);
        }
        
        # even more copy paste:
        for my $key (sort keys %items) {
            my $items = $items{$key};
            my $subsection = $key;
            $subsection =~ s/^\d+(?:\.\d+)? +//;
            $doc .= "## $subsection\n\n";
            # ah and here we sort the symbol instead of go straight:
            for my $sym (sort { lc($a) cmp lc($b) } keys %$items) {
                # only change from copy paste is here:
                my $item = $items->{$sym};
                my $path = $item->headerpath;
                $documented_headerfiles{$path}++;
                my $id = lc($sym);
                $doc .= "* [$sym]($path.md#$id)\n";
            }
            $doc .= "\n";
        }
        $doc
    };
    
    my $outpath = output_path("index");
    xmkdir_p dirname($outpath);

    my $doc = $DOCWARNING;
    # $doc .= "# Documentation index\n\n";

    # Meta
    $doc .= "\n" . xgetfile_utf8("config/index-meta.md") . "\n\n";

    $doc .= "# Files\n\n";
    for my $path (sort keys %documented_headerfiles) {
        $doc .= "* [$path]($path.md)\n\n";
    }

    $doc .= "# Names\n\n";
    $doc .= $doc_Names;
    
    do_append_whitespace_footer(\$doc);

    xputfile_utf8 $outpath, $doc;
}
