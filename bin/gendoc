#!/usr/bin/env perl

my $copyright= <<'COPYRIGHT';
# Copyright 2023 by Christian Jaeger <ch@christianjaeger.ch>
# Published under the same terms as perl itself
COPYRIGHT

use strict;
use utf8;
use warnings;
use warnings FATAL => 'uninitialized';
use experimental 'signatures';

my ($email_full)= $copyright=~ / by ([^\n]*)/s;

my ($mydir, $myname);
BEGIN {
    $0=~ /(.*?)([^\/]+)\z/s or die "?";
    ($mydir, $myname)=($1,$2);
}

#use Chj::ruse;
#use FP::Show; use FP::Repl; use FP::Repl::Trap;#
use Getopt::Long;
use Chj::IO::Command;
use Chj::xperlfunc ":all";
use Chj::xIOUtil "xputfile_utf8";

sub usage {
    print STDERR map{"$_\n"} @_ if @_;
    print "$myname

  Extract API documentation, for all the items following a block of
  lines starting with '///'.

  ($email_full)
";
exit (@_ ? 1 : 0);
}

our $verbose=0;
#our $opt_dry;
GetOptions("verbose"=> \$verbose,
	   "help"=> sub{usage},
	   #"dry-run"=> \$opt_dry,
	   ) or exit 1;
usage if @ARGV;


package DocEntry {
    use FP::Struct [
        "headerpath",
        "bare_docs",
        "bare_prototype",
        "terminator",
        ]=> qw(FP::Struct::Show);

    sub docs($self) {
        my $s = $self->bare_docs;
        $s=~ s{(^|\n)/// ?}{$1}sg;
        $s =~ s{\s+\z}{}s;
        $s
    }

    sub prototype($self) {
        my $s = $self->bare_prototype;
        $s =~ s{^\s+}{}s;
        $s =~ s{\s+\z}{}s;
        # Remove #define, or leave it in? At least canonicalize it
        #$s =~ s{^#\s*define\s+}{#define }s;
        $s =~ s{^#\s*define\s+}{}s;
        $s
    }

    sub symbol($self) {
        my $s = $self->bare_prototype;
        if ($s=~ m{^\s*#\s*define\s+(\w+)}) {
            $1
        } elsif ($s=~ m{^typedef\s+struct\s+(\w+)}) {
            $1
        } elsif ($s=~ m{^typedef\b.*\b(\w+)\s*$}) {
            $1
        } else {
            # Now it gets hard! ucfirst really disambiguates here? !
            if ($s=~ m{ ([a-z]\w*)\s*\(}) {
                $1
            } else {
                die "no match"
            }
        }
    }

    sub kind($self) {
        my $p = $self->bare_prototype;
        if ($p =~ /^\s*#\s*define\s*(\S+)/) {
            my $definitionfirst = $1;
            if ($self->terminator =~ /_Generic/) {
                "2 Generic functions"
            } else {
                #if ($definitionfirst =~ m{\(}) {
                    "3 Macros"
                #} else {
                #    "Constants"
                #}
            }
        } elsif ($p=~ m{^typedef\b(\s+struct\b)?}) {
            $1 ? "0 Types" : "01 Type aliases"
        } else {
            "1 Normal functions"
        }
    }
    
    sub markdown($self) {
        my @code = map {
            "$_\n"
        } split /\n/, $self->prototype;
        my @docs = map {
            "$_\n"
        } split /\n/, $self->docs;
        join("",
             "## " . $self->symbol . "\n",
             "\n",
             "```C\n",
             @code,
             "```\n",
             "",
             @docs)
    }
    _END_
}

my @headerfiles = do {
    my $s = Chj::IO::Command->new_sender(qw(gls-of-suffix h));
    my @l = $s->xreadline;
    $s->xxfinish;
    chomp @l;
    @l
};

my $DOCWARNING = "<!-- THIS FILE WAS AUTO-GENERATED by $myname. DO NOT EDIT! -->\n\n";

sub do_append_whitespace_footer($docref) {
    # Append superfluous space at the end so that it can jump to the
    # right place?
    $$docref .= "<hr>\n";
    for (1..30) {
        $$docref .= "<p>&nbsp;</p>\n";
    }
}

sub output_path($inpath) {
    "doc-output/$inpath.md"
}

my $tripleslashline = qr{(?: /// [^\n]* \n )}xs;
my $topslashline = qr{(?: //\! [^\n]* \n )}xs;
my $emptyline = qr{(?: [ \t]* \n )}xs;
my $docblock = qr{ (?: $emptyline $tripleslashline+  )+ }xs;
my $topblock = qr{ (?: (?: ^ | $emptyline) $topslashline+ )+ }xs;

sub filedocs ($path) {
    my $s = xgetfile_utf8 $path;
    my %items;
    while ($s=~ m{
               ($docblock)
               $emptyline?

               # captured code:
               (
                  # struct definition
                  typedef\s+struct\s+ \w+ \s+\{.*?\}\s* \w+;
                    # ^ the first and second \w+ block should be identical, todo?
                  |
                  .*? # simply whatever up to the terminator
               )
               # terminator:
               (
                    \{                       # function
                  | \\ (?: \s* _Generic)?    # generic
                  | ;                        # ?
                  | \n                       # struct definition, ?
               )
           }xsg) {
        my $e = DocEntry->new( $path, $1, $2, $3 );
        push @{$items{$e->kind}}, $e;
    }
    my ($maybe_topblock) = $s=~ m{ ($topblock) }xs;

    my $doc = $DOCWARNING;
    # $doc .= "# Documentation for $path\n\n";

    if (defined $maybe_topblock) {
        my @lines = map {
            s{^//\! ?}{};
            s{\s+\z}{};
            "$_\n"
        } split /\n/, $maybe_topblock;
        $doc .= join("", @lines)."\n";
    }

    for my $key (sort keys %items) {
        my $items = $items{$key};
        my $subsection = $key;
        $subsection =~ s/^\d+ +//;
        $doc .= "# $subsection\n\n";
        for my $item (@$items) {
            $doc .= $item->markdown."\n";
        }
    }

    do_append_whitespace_footer(\$doc);
    
    my $outpath = output_path($path);
    xmkdir_p dirname($outpath);
    xputfile_utf8 $outpath, $doc;

    \%items
}

my @itemss = map { filedocs($_) } @headerfiles;

{
    my %documented_headerfiles;
    my $doc_Names = do {
        my $doc = ""; # part only
        my %items; # across all pages
        for my $items (@itemss) {
            # partial copy paste of this loop:
            for my $key (sort keys %$items) {
                my $items = $items->{$key};
                for my $item (@$items) {
                    my $symbol = $item->symbol;
                    die "duplicate symbol" if exists $items{$key}{$symbol};
                    $items{$key}{$symbol} = $item;
                }
            }
        }
        # even more copy paste:
        for my $key (sort keys %items) {
            my $items = $items{$key};
            my $subsection = $key;
            $subsection =~ s/^\d+ +//;
            $doc .= "## $subsection\n\n";
            # ah and here we sort the symbol instead of go straight:
            for my $sym (sort { lc($a) cmp lc($b) } keys %$items) {
                # only change from copy paste is here:
                my $item = $items->{$sym};
                my $path = $item->headerpath;
                $documented_headerfiles{$path}++;
                my $id = lc($sym);
                $doc .= "* [$sym]($path.md#$id)\n";
            }
            $doc .= "\n";
        }
        $doc
    };
    
    my $outpath = output_path("index");
    xmkdir_p dirname($outpath);

    my $doc = $DOCWARNING;
    # $doc .= "# Documentation index\n\n";

    $doc .= "# Files\n\n";
    for my $path (sort keys %documented_headerfiles) {
        $doc .= "* [$path]($path.md)\n\n";
    }

    $doc .= "# Names\n\n";
    $doc .= $doc_Names;
    
    do_append_whitespace_footer(\$doc);

    xputfile_utf8 $outpath, $doc;
}
